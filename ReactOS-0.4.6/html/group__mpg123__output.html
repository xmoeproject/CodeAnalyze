<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ReactOS: mpg123 output audio format</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ReactOS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','搜索');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">枚举</a> &#124;
<a href="#func-members">函数</a>  </div>
  <div class="headertitle">
<div class="title">mpg123 output audio format</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
枚举</h2></td></tr>
<tr class="memitem:ga94df916cae2fc81b8a6df88c1728eb1c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpg123__output.html#ga94df916cae2fc81b8a6df88c1728eb1c">mpg123_channelcount</a> { <a class="el" href="group__mpg123__output.html#gga94df916cae2fc81b8a6df88c1728eb1ca5429c88158462f4290639ec505227c0c">MPG123_MONO</a> = 1, 
<a class="el" href="group__mpg123__output.html#gga94df916cae2fc81b8a6df88c1728eb1ca52d7aff6b35da496e7f430b37c0d4602">MPG123_STEREO</a> = 2
 }</td></tr>
<tr class="separator:ga94df916cae2fc81b8a6df88c1728eb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:gac01392beb95e85d2ba165d4a3630f52a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> <a class="el" href="interfacevoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpg123__output.html#gac01392beb95e85d2ba165d4a3630f52a">mpg123_rates</a> (const long **<a class="el" href="classlist.html">list</a>, size_t *number)</td></tr>
<tr class="separator:gac01392beb95e85d2ba165d4a3630f52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdf7009c888364527de2bdf37aa36185"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> <a class="el" href="interfacevoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpg123__output.html#gabdf7009c888364527de2bdf37aa36185">mpg123_encodings</a> (const int **<a class="el" href="classlist.html">list</a>, size_t *number)</td></tr>
<tr class="separator:gabdf7009c888364527de2bdf37aa36185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf12bd45d9040973c8c7b7b9411a530b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpg123__output.html#gaf12bd45d9040973c8c7b7b9411a530b5">mpg123_encsize</a> (int encoding)</td></tr>
<tr class="separator:gaf12bd45d9040973c8c7b7b9411a530b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga931ca238347de394901c3baa13e7a8f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpg123__output.html#ga931ca238347de394901c3baa13e7a8f8">mpg123_format_none</a> (<a class="el" href="group__mpg123__init.html#ga6728e2839a395f3a07d4514da659faca">mpg123_handle</a> *mh)</td></tr>
<tr class="separator:ga931ca238347de394901c3baa13e7a8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65a28420ccab9021abd44ae95db8b1b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpg123__output.html#ga65a28420ccab9021abd44ae95db8b1b6">mpg123_format_all</a> (<a class="el" href="group__mpg123__init.html#ga6728e2839a395f3a07d4514da659faca">mpg123_handle</a> *mh)</td></tr>
<tr class="separator:ga65a28420ccab9021abd44ae95db8b1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadad5794afc300a997e517dbe397dc2c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpg123__output.html#gadad5794afc300a997e517dbe397dc2c7">mpg123_format</a> (<a class="el" href="group__mpg123__init.html#ga6728e2839a395f3a07d4514da659faca">mpg123_handle</a> *mh, long rate, int channels, int encodings)</td></tr>
<tr class="separator:gadad5794afc300a997e517dbe397dc2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae30accfd052c88aad47820c5bb149cda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpg123__output.html#gae30accfd052c88aad47820c5bb149cda">mpg123_format_support</a> (<a class="el" href="group__mpg123__init.html#ga6728e2839a395f3a07d4514da659faca">mpg123_handle</a> *mh, long rate, int encoding)</td></tr>
<tr class="separator:gae30accfd052c88aad47820c5bb149cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5e04c7522d620e122009db359cc6dc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpg123__output.html#gae5e04c7522d620e122009db359cc6dc5">mpg123_getformat</a> (<a class="el" href="group__mpg123__init.html#ga6728e2839a395f3a07d4514da659faca">mpg123_handle</a> *mh, long *rate, int *channels, int *encoding)</td></tr>
<tr class="separator:gae5e04c7522d620e122009db359cc6dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf21a63d9ab2fc87e271962f6f583876"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpg123__output.html#gadf21a63d9ab2fc87e271962f6f583876">mpg123_getformat2</a> (<a class="el" href="group__mpg123__init.html#ga6728e2839a395f3a07d4514da659faca">mpg123_handle</a> *mh, long *rate, int *channels, int *encoding, int clear_flag)</td></tr>
<tr class="separator:gadf21a63d9ab2fc87e271962f6f583876"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<p>Functions to get and select the format of the decoded audio.</p>
<p>Before you dive in, please be warned that you might get confused by this. <a class="el" href="namespace_this.html">This</a> seems to happen a lot, therefore I am trying to explain in advance.</p>
<p>The mpg123 library decides what output format to use when encountering the first frame in a stream, or actually any frame that is still valid but differs from the frames before in the prompted output format. At such a deciding point, an internal table of allowed encodings, sampling rates and channel setups is consulted. According to this table, an output format is chosen and the decoding engine set up accordingly (including optimized routines for different output formats). <a class="el" href="namespace_this.html">This</a> might seem unusual but it just follows from the non-existence of "MPEG audio files" with defined overall properties. There are streams, streams are concatenations of (semi) independent frames. We store streams on disk and call them "MPEG audio files", but that does not change their nature as the decoder is concerned (the LAME/Xing header for gapless decoding makes things interesting again).</p>
<p>To get to the point: What you do with <a class="el" href="group__mpg123__output.html#gadad5794afc300a997e517dbe397dc2c7">mpg123_format()</a> and friends is to fill the internal table of allowed formats before it is used. That includes removing support for some formats or adding your forced sample rate (see MPG123_FORCE_RATE) that will be used with the crude internal resampler. Also keep in mind that the sample encoding is just a question of choice &ndash; the MPEG frames do only indicate their native sampling rate and channel count. If you want to decode to integer or float samples, 8 or 16 bit ... that is your decision. In a "clean" world, libmpg123 would always decode to 32 bit float and let you handle any sample conversion. But there are optimized routines that work faster by directly decoding to the desired encoding / accuracy. We prefer efficiency over conceptual tidyness.</p>
<p>People often start out thinking that <a class="el" href="group__mpg123__output.html#gadad5794afc300a997e517dbe397dc2c7">mpg123_format()</a> should change the actual decoding format on the fly. That is wrong. <a class="el" href="class_it.html">It</a> only has effect on the next natural change of output format, when libmpg123 will consult its format table again. To make life easier, you might want to call <a class="el" href="group__mpg123__output.html#ga931ca238347de394901c3baa13e7a8f8">mpg123_format_none()</a> before any thing else and then just allow one desired encoding and a limited set of sample rates / channel choices that you actually intend to deal with. You can force libmpg123 to decode everything to 44100 KHz, stereo, 16 bit integer ... it will duplicate mono channels and even do resampling if needed (unless that feature is disabled in the build, same with some encodings). But I have to stress that the resampling of libmpg123 is very crude and doesn't even contain any kind of "proper" interpolation.</p>
<p>In any case, watch out for MPG123_NEW_FORMAT as return message from decoding routines and call <a class="el" href="group__mpg123__output.html#gae5e04c7522d620e122009db359cc6dc5">mpg123_getformat()</a> to get the currently active output format. </p>
<h2 class="groupheader">枚举类型说明</h2>
<a id="ga94df916cae2fc81b8a6df88c1728eb1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94df916cae2fc81b8a6df88c1728eb1c">&#9670;&nbsp;</a></span>mpg123_channelcount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceenum.html">enum</a> <a class="el" href="group__mpg123__output.html#ga94df916cae2fc81b8a6df88c1728eb1c">mpg123_channelcount</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>They can be combined into one number (3) to indicate mono and stereo... </p>
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="gga94df916cae2fc81b8a6df88c1728eb1ca5429c88158462f4290639ec505227c0c"></a>MPG123_MONO&#160;</td><td class="fielddoc"><p>mono </p>
</td></tr>
<tr><td class="fieldname"><a id="gga94df916cae2fc81b8a6df88c1728eb1ca52d7aff6b35da496e7f430b37c0d4602"></a>MPG123_STEREO&#160;</td><td class="fielddoc"><p>stereo </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">函数说明</h2>
<a id="gabdf7009c888364527de2bdf37aa36185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdf7009c888364527de2bdf37aa36185">&#9670;&nbsp;</a></span>mpg123_encodings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> <a class="el" href="interfacevoid.html">void</a> mpg123_encodings </td>
          <td>(</td>
          <td class="paramtype">const int **&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An array of supported audio encodings. An audio encoding is one of the fully qualified members of mpg123_enc_enum (MPG123_ENC_SIGNED_16, not MPG123_SIGNED). </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Store a pointer to the encodings array there. </td></tr>
    <tr><td class="paramname">number</td><td>Store the number of encodings there. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf12bd45d9040973c8c7b7b9411a530b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf12bd45d9040973c8c7b7b9411a530b5">&#9670;&nbsp;</a></span>mpg123_encsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> int mpg123_encsize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>encoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the size (in bytes) of one mono sample of the named encoding. </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoding</td><td>The encoding value to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>positive size of encoding in bytes, 0 on invalid encoding. </dd></dl>

</div>
</div>
<a id="gadad5794afc300a997e517dbe397dc2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadad5794afc300a997e517dbe397dc2c7">&#9670;&nbsp;</a></span>mpg123_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> int mpg123_format </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mpg123__init.html#ga6728e2839a395f3a07d4514da659faca">mpg123_handle</a> *&#160;</td>
          <td class="paramname"><em>mh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>encodings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the audio format support of a mpg123_handle in detail: </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mh</td><td>handle </td></tr>
    <tr><td class="paramname">rate</td><td>The sample rate value (in Hertz). </td></tr>
    <tr><td class="paramname">channels</td><td><a class="el" href="struct_a.html">A</a> combination of MPG123_STEREO and MPG123_MONO. </td></tr>
    <tr><td class="paramname">encodings</td><td><a class="el" href="struct_a.html">A</a> combination of accepted encodings for rate and channels, p.ex MPG123_ENC_SIGNED16 | MPG123_ENC_ULAW_8 (or 0 for no support). Please note that some encodings may not be supported in the library build and thus will be ignored here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>MPG123_OK on success, MPG123_ERR if there was an error. </dd></dl>

</div>
</div>
<a id="ga65a28420ccab9021abd44ae95db8b1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65a28420ccab9021abd44ae95db8b1b6">&#9670;&nbsp;</a></span>mpg123_format_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> int mpg123_format_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mpg123__init.html#ga6728e2839a395f3a07d4514da659faca">mpg123_handle</a> *&#160;</td>
          <td class="paramname"><em>mh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure mpg123 handle to accept all formats (also any custom rate you may set) &ndash; this is default. </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mh</td><td>handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>MPG123_OK on success </dd></dl>

</div>
</div>
<a id="ga931ca238347de394901c3baa13e7a8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga931ca238347de394901c3baa13e7a8f8">&#9670;&nbsp;</a></span>mpg123_format_none()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> int mpg123_format_none </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mpg123__init.html#ga6728e2839a395f3a07d4514da659faca">mpg123_handle</a> *&#160;</td>
          <td class="paramname"><em>mh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure a mpg123 handle to accept no output format at all, use before specifying supported formats with mpg123_format </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mh</td><td>handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>MPG123_OK on success </dd></dl>

</div>
</div>
<a id="gae30accfd052c88aad47820c5bb149cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae30accfd052c88aad47820c5bb149cda">&#9670;&nbsp;</a></span>mpg123_format_support()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> int mpg123_format_support </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mpg123__init.html#ga6728e2839a395f3a07d4514da659faca">mpg123_handle</a> *&#160;</td>
          <td class="paramname"><em>mh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check to see if a specific format at a specific rate is supported by mpg123_handle. </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mh</td><td>handle </td></tr>
    <tr><td class="paramname">rate</td><td>sampling rate </td></tr>
    <tr><td class="paramname">encoding</td><td>encoding </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>0 for no support (that includes invalid parameters), MPG123_STEREO, MPG123_MONO or MPG123_STEREO|MPG123_MONO. </dd></dl>

</div>
</div>
<a id="gae5e04c7522d620e122009db359cc6dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5e04c7522d620e122009db359cc6dc5">&#9670;&nbsp;</a></span>mpg123_getformat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> int mpg123_getformat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mpg123__init.html#ga6728e2839a395f3a07d4514da659faca">mpg123_handle</a> *&#160;</td>
          <td class="paramname"><em>mh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current output format written to the addresses given. If the stream is freshly loaded, this will try to parse enough of it to give you the format to come. <a class="el" href="namespace_this.html">This</a> clears the flag that would otherwise make the first decoding call return MPG123_NEW_FORMAT. </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mh</td><td>handle </td></tr>
    <tr><td class="paramname">rate</td><td>sampling rate return address </td></tr>
    <tr><td class="paramname">channels</td><td>channel count return address </td></tr>
    <tr><td class="paramname">encoding</td><td>encoding return address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>MPG123_OK on success </dd></dl>

</div>
</div>
<a id="gadf21a63d9ab2fc87e271962f6f583876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf21a63d9ab2fc87e271962f6f583876">&#9670;&nbsp;</a></span>mpg123_getformat2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> int mpg123_getformat2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mpg123__init.html#ga6728e2839a395f3a07d4514da659faca">mpg123_handle</a> *&#160;</td>
          <td class="paramname"><em>mh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clear_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current output format written to the addresses given. <a class="el" href="namespace_this.html">This</a> differs from plain <a class="el" href="group__mpg123__output.html#gae5e04c7522d620e122009db359cc6dc5">mpg123_getformat()</a> in that you can choose <em>not</em> to clear the flag that would trigger the next decoding call to return MPG123_NEW_FORMAT in case of a new format arriving. </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mh</td><td>handle </td></tr>
    <tr><td class="paramname">rate</td><td>sampling rate return address </td></tr>
    <tr><td class="paramname">channels</td><td>channel count return address </td></tr>
    <tr><td class="paramname">encoding</td><td>encoding return address </td></tr>
    <tr><td class="paramname">clear_flag</td><td>if true, clear internal format flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>MPG123_OK on success </dd></dl>

</div>
</div>
<a id="gac01392beb95e85d2ba165d4a3630f52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac01392beb95e85d2ba165d4a3630f52a">&#9670;&nbsp;</a></span>mpg123_rates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mpg123_8h.html#a2ba98cfba3f760879df70e755b2a61cc">MPG123_EXPORT</a> <a class="el" href="interfacevoid.html">void</a> mpg123_rates </td>
          <td>(</td>
          <td class="paramtype">const long **&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An array of supported standard sample rates These are possible native sample rates of MPEG audio files. You can still force mpg123 to resample to a different one, but by default you will only get audio in one of these samplings. </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Store a pointer to the sample rates array there. </td></tr>
    <tr><td class="paramname">number</td><td>Store the number of sample rates there. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
