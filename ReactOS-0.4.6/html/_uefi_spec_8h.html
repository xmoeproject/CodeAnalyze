<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ReactOS: E:/ReactOS-0.4.6/boot/environ/include/efi/UefiSpec.h 文件参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ReactOS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','搜索');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_885cc87fac2d91e269af0a5a959fa5f6.html">E:</a></li><li class="navelem"><a class="el" href="dir_feba3295545e8249e77d6dc9962d412f.html">ReactOS-0.4.6</a></li><li class="navelem"><a class="el" href="dir_b3615e6e0b22341053cbe86773a25661.html">boot</a></li><li class="navelem"><a class="el" href="dir_3fa9dcb97c75d5cbeedae087da712fee.html">environ</a></li><li class="navelem"><a class="el" href="dir_ec4c323b5f694edd4712112e1aacd156.html">include</a></li><li class="navelem"><a class="el" href="dir_82e0c89cf4bc9dcd1f3a1bfca7bb5bfa.html">efi</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">类</a> &#124;
<a href="#define-members">宏定义</a> &#124;
<a href="#typedef-members">类型定义</a> &#124;
<a href="#enum-members">枚举</a>  </div>
  <div class="headertitle">
<div class="title">UefiSpec.h 文件参考</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="_uefi_multi_phase_8h_source.html">UefiMultiPhase.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="_device_path_8h_source.html">DevicePath.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="_simple_text_in_8h_source.html">SimpleTextIn.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="_simple_text_in_ex_8h_source.html">SimpleTextInEx.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="_simple_text_out_8h_source.html">SimpleTextOut.h</a>&gt;</code><br />
</div>
<p><a href="_uefi_spec_8h_source.html">浏览源代码.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___m_e_m_o_r_y___d_e_s_c_r_i_p_t_o_r.html">EFI_MEMORY_DESCRIPTOR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___t_i_m_e___c_a_p_a_b_i_l_i_t_i_e_s.html">EFI_TIME_CAPABILITIES</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___o_p_e_n___p_r_o_t_o_c_o_l___i_n_f_o_r_m_a_t_i_o_n___e_n_t_r_y.html">EFI_OPEN_PROTOCOL_INFORMATION_ENTRY</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___c_a_p_s_u_l_e___b_l_o_c_k___d_e_s_c_r_i_p_t_o_r.html">EFI_CAPSULE_BLOCK_DESCRIPTOR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___c_a_p_s_u_l_e___h_e_a_d_e_r.html">EFI_CAPSULE_HEADER</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___c_a_p_s_u_l_e___t_a_b_l_e.html">EFI_CAPSULE_TABLE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___r_u_n_t_i_m_e___s_e_r_v_i_c_e_s.html">EFI_RUNTIME_SERVICES</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___b_o_o_t___s_e_r_v_i_c_e_s.html">EFI_BOOT_SERVICES</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___c_o_n_f_i_g_u_r_a_t_i_o_n___t_a_b_l_e.html">EFI_CONFIGURATION_TABLE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___s_y_s_t_e_m___t_a_b_l_e.html">EFI_SYSTEM_TABLE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_e_f_i___b_o_o_t___k_e_y___d_a_t_a.html">EFI_BOOT_KEY_DATA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_f_i___k_e_y___o_p_t_i_o_n.html">EFI_KEY_OPTION</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
宏定义</h2></td></tr>
<tr class="memitem:a6b22f77920c80d29d2f0b7c87aae5fe9"><td class="memItemLeft" align="right" valign="top"><a id="a6b22f77920c80d29d2f0b7c87aae5fe9"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_TIME_ADJUST_DAYLIGHT</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:a6b22f77920c80d29d2f0b7c87aae5fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84664917f324b52219777d221973bd0e"><td class="memItemLeft" align="right" valign="top"><a id="a84664917f324b52219777d221973bd0e"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_TIME_IN_DAYLIGHT</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:a84664917f324b52219777d221973bd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4896509d679c752bd4bcd474ac66858a"><td class="memItemLeft" align="right" valign="top">#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a4896509d679c752bd4bcd474ac66858a">EFI_UNSPECIFIED_TIMEZONE</a>&#160;&#160;&#160;0x07FF</td></tr>
<tr class="separator:a4896509d679c752bd4bcd474ac66858a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad648d958616b31df1767e34c9f526077"><td class="memItemLeft" align="right" valign="top"><a id="ad648d958616b31df1767e34c9f526077"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_MEMORY_UC</b>&#160;&#160;&#160;0x0000000000000001ULL</td></tr>
<tr class="separator:ad648d958616b31df1767e34c9f526077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390993cf55270e6a588a1fdc100b2f01"><td class="memItemLeft" align="right" valign="top"><a id="a390993cf55270e6a588a1fdc100b2f01"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_MEMORY_WC</b>&#160;&#160;&#160;0x0000000000000002ULL</td></tr>
<tr class="separator:a390993cf55270e6a588a1fdc100b2f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a407f5f251230585690521e2b6c83c"><td class="memItemLeft" align="right" valign="top"><a id="a19a407f5f251230585690521e2b6c83c"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_MEMORY_WT</b>&#160;&#160;&#160;0x0000000000000004ULL</td></tr>
<tr class="separator:a19a407f5f251230585690521e2b6c83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98873412697c23bfda3a806436f3b21e"><td class="memItemLeft" align="right" valign="top"><a id="a98873412697c23bfda3a806436f3b21e"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_MEMORY_WB</b>&#160;&#160;&#160;0x0000000000000008ULL</td></tr>
<tr class="separator:a98873412697c23bfda3a806436f3b21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49507db04dc48671760185fcf23845c6"><td class="memItemLeft" align="right" valign="top"><a id="a49507db04dc48671760185fcf23845c6"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_MEMORY_UCE</b>&#160;&#160;&#160;0x0000000000000010ULL</td></tr>
<tr class="separator:a49507db04dc48671760185fcf23845c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4f3f58f478bc13fae79ed01865e141"><td class="memItemLeft" align="right" valign="top"><a id="a7b4f3f58f478bc13fae79ed01865e141"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_MEMORY_WP</b>&#160;&#160;&#160;0x0000000000001000ULL</td></tr>
<tr class="separator:a7b4f3f58f478bc13fae79ed01865e141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f400829479852b940dd19abfe9ae9e5"><td class="memItemLeft" align="right" valign="top"><a id="a0f400829479852b940dd19abfe9ae9e5"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_MEMORY_RP</b>&#160;&#160;&#160;0x0000000000002000ULL</td></tr>
<tr class="separator:a0f400829479852b940dd19abfe9ae9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bffa24092545510f7db53212c1fdf1"><td class="memItemLeft" align="right" valign="top"><a id="ac5bffa24092545510f7db53212c1fdf1"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_MEMORY_XP</b>&#160;&#160;&#160;0x0000000000004000ULL</td></tr>
<tr class="separator:ac5bffa24092545510f7db53212c1fdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00105729c753432e428c7f953ba290c3"><td class="memItemLeft" align="right" valign="top"><a id="a00105729c753432e428c7f953ba290c3"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_MEMORY_RUNTIME</b>&#160;&#160;&#160;0x8000000000000000ULL</td></tr>
<tr class="separator:a00105729c753432e428c7f953ba290c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02d5d59fffd00ef796b7e6d33635237"><td class="memItemLeft" align="right" valign="top">#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#ac02d5d59fffd00ef796b7e6d33635237">EFI_MEMORY_DESCRIPTOR_VERSION</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ac02d5d59fffd00ef796b7e6d33635237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4b0228075345649400209a649661a4"><td class="memItemLeft" align="right" valign="top"><a id="a1f4b0228075345649400209a649661a4"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_OPTIONAL_PTR</b>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:a1f4b0228075345649400209a649661a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa156648f75dbc98d4918eb4ec86b67b2"><td class="memItemLeft" align="right" valign="top"><a id="aa156648f75dbc98d4918eb4ec86b67b2"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EVT_TIMER</b>&#160;&#160;&#160;0x80000000</td></tr>
<tr class="separator:aa156648f75dbc98d4918eb4ec86b67b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c642c3426517c8c43ae6714db9242df"><td class="memItemLeft" align="right" valign="top"><a id="a0c642c3426517c8c43ae6714db9242df"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EVT_RUNTIME</b>&#160;&#160;&#160;0x40000000</td></tr>
<tr class="separator:a0c642c3426517c8c43ae6714db9242df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e24af1f2700d8f777095092c41f76a"><td class="memItemLeft" align="right" valign="top"><a id="aa4e24af1f2700d8f777095092c41f76a"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EVT_NOTIFY_WAIT</b>&#160;&#160;&#160;0x00000100</td></tr>
<tr class="separator:aa4e24af1f2700d8f777095092c41f76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95737531e77918c81f754152c5b68b2"><td class="memItemLeft" align="right" valign="top"><a id="ad95737531e77918c81f754152c5b68b2"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EVT_NOTIFY_SIGNAL</b>&#160;&#160;&#160;0x00000200</td></tr>
<tr class="separator:ad95737531e77918c81f754152c5b68b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f537ad66fcd33288ea2469620f2f295"><td class="memItemLeft" align="right" valign="top"><a id="a1f537ad66fcd33288ea2469620f2f295"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EVT_SIGNAL_EXIT_BOOT_SERVICES</b>&#160;&#160;&#160;0x00000201</td></tr>
<tr class="separator:a1f537ad66fcd33288ea2469620f2f295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c046dcd14e317217ebe1b7367409d5"><td class="memItemLeft" align="right" valign="top"><a id="a56c046dcd14e317217ebe1b7367409d5"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE</b>&#160;&#160;&#160;0x60000202</td></tr>
<tr class="separator:a56c046dcd14e317217ebe1b7367409d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917fbe67fe21b8a486d3f106f252d669"><td class="memItemLeft" align="right" valign="top"><a id="a917fbe67fe21b8a486d3f106f252d669"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EVT_RUNTIME_CONTEXT</b>&#160;&#160;&#160;0x20000000</td></tr>
<tr class="separator:a917fbe67fe21b8a486d3f106f252d669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6532a3ece94e363fc7bc36a108cc3478"><td class="memItemLeft" align="right" valign="top"><a id="a6532a3ece94e363fc7bc36a108cc3478"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TPL_APPLICATION</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a6532a3ece94e363fc7bc36a108cc3478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0687858c391361693fe5358a961f3dbc"><td class="memItemLeft" align="right" valign="top"><a id="a0687858c391361693fe5358a961f3dbc"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TPL_CALLBACK</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a0687858c391361693fe5358a961f3dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2dd0dc7c342007c3f5241afdd7260ad"><td class="memItemLeft" align="right" valign="top"><a id="aa2dd0dc7c342007c3f5241afdd7260ad"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TPL_NOTIFY</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:aa2dd0dc7c342007c3f5241afdd7260ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aed58135c283d9eff49de35eccbd308"><td class="memItemLeft" align="right" valign="top"><a id="a2aed58135c283d9eff49de35eccbd308"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TPL_HIGH_LEVEL</b>&#160;&#160;&#160;31</td></tr>
<tr class="separator:a2aed58135c283d9eff49de35eccbd308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d84218b44f5663fda6b194a2e3c47d"><td class="memItemLeft" align="right" valign="top"><a id="a74d84218b44f5663fda6b194a2e3c47d"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL</b>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:a74d84218b44f5663fda6b194a2e3c47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c8928d1a8a394503d01bcef06fe6bb"><td class="memItemLeft" align="right" valign="top"><a id="a87c8928d1a8a394503d01bcef06fe6bb"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_OPEN_PROTOCOL_GET_PROTOCOL</b>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:a87c8928d1a8a394503d01bcef06fe6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554b5e899bd6cc2ba604db85d36ffdfe"><td class="memItemLeft" align="right" valign="top"><a id="a554b5e899bd6cc2ba604db85d36ffdfe"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_OPEN_PROTOCOL_TEST_PROTOCOL</b>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="separator:a554b5e899bd6cc2ba604db85d36ffdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd30c89369409ab0e3567d38b3cd59e1"><td class="memItemLeft" align="right" valign="top"><a id="afd30c89369409ab0e3567d38b3cd59e1"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER</b>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="separator:afd30c89369409ab0e3567d38b3cd59e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d437ae977390a2d6eb3f7712ed2440b"><td class="memItemLeft" align="right" valign="top"><a id="a2d437ae977390a2d6eb3f7712ed2440b"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_OPEN_PROTOCOL_BY_DRIVER</b>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="separator:a2d437ae977390a2d6eb3f7712ed2440b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d96e9e15c0e0705e5183faf3b72052"><td class="memItemLeft" align="right" valign="top"><a id="aa9d96e9e15c0e0705e5183faf3b72052"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_OPEN_PROTOCOL_EXCLUSIVE</b>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="separator:aa9d96e9e15c0e0705e5183faf3b72052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09e88c8e544d9fbea91e2a61c92069d"><td class="memItemLeft" align="right" valign="top"><a id="af09e88c8e544d9fbea91e2a61c92069d"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CAPSULE_FLAGS_PERSIST_ACROSS_RESET</b>&#160;&#160;&#160;0x00010000</td></tr>
<tr class="separator:af09e88c8e544d9fbea91e2a61c92069d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e85483d373a1df19513050b5bd87a9"><td class="memItemLeft" align="right" valign="top"><a id="ab8e85483d373a1df19513050b5bd87a9"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CAPSULE_FLAGS_POPULATE_SYSTEM_TABLE</b>&#160;&#160;&#160;0x00020000</td></tr>
<tr class="separator:ab8e85483d373a1df19513050b5bd87a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ffe6c19f70ae3f90d68b2f785b4ee1"><td class="memItemLeft" align="right" valign="top"><a id="a35ffe6c19f70ae3f90d68b2f785b4ee1"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CAPSULE_FLAGS_INITIATE_RESET</b>&#160;&#160;&#160;0x00040000</td></tr>
<tr class="separator:a35ffe6c19f70ae3f90d68b2f785b4ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652657e3357138b039bda4e5be02813c"><td class="memItemLeft" align="right" valign="top"><a id="a652657e3357138b039bda4e5be02813c"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_SYSTEM_TABLE_SIGNATURE</b>&#160;&#160;&#160;<a class="el" href="boot_2environ_2include_2efi_2_base_8h.html#a9d9b94d5fd98904e7ea66dc92778fcc4">SIGNATURE_64</a> ('I','B','I',' ','<a class="el" href="struct_s.html">S</a>','Y','<a class="el" href="struct_s.html">S</a>','T')</td></tr>
<tr class="separator:a652657e3357138b039bda4e5be02813c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2851fa609a8a5cd294ec31b9cce2b9c"><td class="memItemLeft" align="right" valign="top"><a id="aa2851fa609a8a5cd294ec31b9cce2b9c"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_2_31_SYSTEM_TABLE_REVISION</b>&#160;&#160;&#160;((2 &lt;&lt; 16) | (31))</td></tr>
<tr class="separator:aa2851fa609a8a5cd294ec31b9cce2b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8c1a00c7602c4eda10da85c1739d49"><td class="memItemLeft" align="right" valign="top"><a id="aaa8c1a00c7602c4eda10da85c1739d49"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_2_30_SYSTEM_TABLE_REVISION</b>&#160;&#160;&#160;((2 &lt;&lt; 16) | (30))</td></tr>
<tr class="separator:aaa8c1a00c7602c4eda10da85c1739d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1688823a7831d1a0063744751b8498"><td class="memItemLeft" align="right" valign="top"><a id="aea1688823a7831d1a0063744751b8498"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_2_20_SYSTEM_TABLE_REVISION</b>&#160;&#160;&#160;((2 &lt;&lt; 16) | (20))</td></tr>
<tr class="separator:aea1688823a7831d1a0063744751b8498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e0b34b2a04b81d85a7e786f9a41492"><td class="memItemLeft" align="right" valign="top"><a id="af0e0b34b2a04b81d85a7e786f9a41492"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_2_10_SYSTEM_TABLE_REVISION</b>&#160;&#160;&#160;((2 &lt;&lt; 16) | (10))</td></tr>
<tr class="separator:af0e0b34b2a04b81d85a7e786f9a41492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7c50d4ac546fbd8b1edc01a47cb782"><td class="memItemLeft" align="right" valign="top"><a id="afe7c50d4ac546fbd8b1edc01a47cb782"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_2_00_SYSTEM_TABLE_REVISION</b>&#160;&#160;&#160;((2 &lt;&lt; 16) | (00))</td></tr>
<tr class="separator:afe7c50d4ac546fbd8b1edc01a47cb782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7e0872c1ec22bd9df7e746b1f3d085"><td class="memItemLeft" align="right" valign="top"><a id="a3a7e0872c1ec22bd9df7e746b1f3d085"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_1_10_SYSTEM_TABLE_REVISION</b>&#160;&#160;&#160;((1 &lt;&lt; 16) | (10))</td></tr>
<tr class="separator:a3a7e0872c1ec22bd9df7e746b1f3d085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094e5b8f8f9ad92057f44779371ee250"><td class="memItemLeft" align="right" valign="top"><a id="a094e5b8f8f9ad92057f44779371ee250"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_1_02_SYSTEM_TABLE_REVISION</b>&#160;&#160;&#160;((1 &lt;&lt; 16) | (02))</td></tr>
<tr class="separator:a094e5b8f8f9ad92057f44779371ee250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef2d0ef7468b81082dd7a36f17bcddb"><td class="memItemLeft" align="right" valign="top"><a id="a5ef2d0ef7468b81082dd7a36f17bcddb"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_SYSTEM_TABLE_REVISION</b>&#160;&#160;&#160;EFI_2_31_SYSTEM_TABLE_REVISION</td></tr>
<tr class="separator:a5ef2d0ef7468b81082dd7a36f17bcddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e35d2b61ba1879b0fadc6ba4ed2340"><td class="memItemLeft" align="right" valign="top"><a id="ae6e35d2b61ba1879b0fadc6ba4ed2340"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_RUNTIME_SERVICES_SIGNATURE</b>&#160;&#160;&#160;<a class="el" href="boot_2environ_2include_2efi_2_base_8h.html#a9d9b94d5fd98904e7ea66dc92778fcc4">SIGNATURE_64</a> ('R','U','N','T','<a class="el" href="struct_s.html">S</a>','E','R','<a class="el" href="struct_v.html">V</a>')</td></tr>
<tr class="separator:ae6e35d2b61ba1879b0fadc6ba4ed2340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f18c5907e9f92808e8961130918f674"><td class="memItemLeft" align="right" valign="top"><a id="a8f18c5907e9f92808e8961130918f674"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_RUNTIME_SERVICES_REVISION</b>&#160;&#160;&#160;EFI_2_31_SYSTEM_TABLE_REVISION</td></tr>
<tr class="separator:a8f18c5907e9f92808e8961130918f674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4eed2bbc7fe43f2836a1b0cf3468468"><td class="memItemLeft" align="right" valign="top"><a id="ac4eed2bbc7fe43f2836a1b0cf3468468"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_BOOT_SERVICES_SIGNATURE</b>&#160;&#160;&#160;<a class="el" href="boot_2environ_2include_2efi_2_base_8h.html#a9d9b94d5fd98904e7ea66dc92778fcc4">SIGNATURE_64</a> ('B','O','O','T','<a class="el" href="struct_s.html">S</a>','E','R','<a class="el" href="struct_v.html">V</a>')</td></tr>
<tr class="separator:ac4eed2bbc7fe43f2836a1b0cf3468468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4a3d6064a02ce4e3421e2d1d5e4459"><td class="memItemLeft" align="right" valign="top"><a id="aed4a3d6064a02ce4e3421e2d1d5e4459"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_BOOT_SERVICES_REVISION</b>&#160;&#160;&#160;EFI_2_31_SYSTEM_TABLE_REVISION</td></tr>
<tr class="separator:aed4a3d6064a02ce4e3421e2d1d5e4459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18834b320974564ef81772077ff84f81"><td class="memItemLeft" align="right" valign="top"><a id="a18834b320974564ef81772077ff84f81"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOAD_OPTION_ACTIVE</b>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:a18834b320974564ef81772077ff84f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0542045aaad3690872acfbed19f772a"><td class="memItemLeft" align="right" valign="top"><a id="ae0542045aaad3690872acfbed19f772a"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOAD_OPTION_FORCE_RECONNECT</b>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:ae0542045aaad3690872acfbed19f772a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba0a2557444eb5f25f2db71e246990f"><td class="memItemLeft" align="right" valign="top"><a id="a2ba0a2557444eb5f25f2db71e246990f"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOAD_OPTION_HIDDEN</b>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="separator:a2ba0a2557444eb5f25f2db71e246990f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36886eba9a4bb95d45bf524d189b148"><td class="memItemLeft" align="right" valign="top"><a id="aa36886eba9a4bb95d45bf524d189b148"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOAD_OPTION_CATEGORY</b>&#160;&#160;&#160;0x00001F00</td></tr>
<tr class="separator:aa36886eba9a4bb95d45bf524d189b148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ae601878535090890255ee0ba338dd"><td class="memItemLeft" align="right" valign="top"><a id="ab4ae601878535090890255ee0ba338dd"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOAD_OPTION_CATEGORY_BOOT</b>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="separator:ab4ae601878535090890255ee0ba338dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40521e9c4be403e230f838b90376f71"><td class="memItemLeft" align="right" valign="top"><a id="ab40521e9c4be403e230f838b90376f71"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LOAD_OPTION_CATEGORY_APP</b>&#160;&#160;&#160;0x00000100</td></tr>
<tr class="separator:ab40521e9c4be403e230f838b90376f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f515560d79e94cb27b5a65235d0dcf0"><td class="memItemLeft" align="right" valign="top"><a id="a0f515560d79e94cb27b5a65235d0dcf0"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_BOOT_OPTION_SUPPORT_KEY</b>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:a0f515560d79e94cb27b5a65235d0dcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c89e0301e934de649603d0a11befb40"><td class="memItemLeft" align="right" valign="top"><a id="a2c89e0301e934de649603d0a11befb40"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_BOOT_OPTION_SUPPORT_APP</b>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:a2c89e0301e934de649603d0a11befb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b4b122ca1957016b4766c70c29b229"><td class="memItemLeft" align="right" valign="top"><a id="af2b4b122ca1957016b4766c70c29b229"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_BOOT_OPTION_SUPPORT_COUNT</b>&#160;&#160;&#160;0x00000300</td></tr>
<tr class="separator:af2b4b122ca1957016b4766c70c29b229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcded598e287cdf39d9bad6c307a3fe"><td class="memItemLeft" align="right" valign="top"><a id="a5bcded598e287cdf39d9bad6c307a3fe"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_REMOVABLE_MEDIA_FILE_NAME_IA32</b>&#160;&#160;&#160;L&quot;\\EFI\\BOOT\\BOOTIA32.EFI&quot;</td></tr>
<tr class="separator:a5bcded598e287cdf39d9bad6c307a3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbb555ff56709f88e36d9456e9d02c1"><td class="memItemLeft" align="right" valign="top"><a id="adfbb555ff56709f88e36d9456e9d02c1"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_REMOVABLE_MEDIA_FILE_NAME_IA64</b>&#160;&#160;&#160;L&quot;\\EFI\\BOOT\\BOOTIA64.EFI&quot;</td></tr>
<tr class="separator:adfbb555ff56709f88e36d9456e9d02c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c834c565bbe0a64cef95edea23f06b"><td class="memItemLeft" align="right" valign="top"><a id="a34c834c565bbe0a64cef95edea23f06b"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_REMOVABLE_MEDIA_FILE_NAME_X64</b>&#160;&#160;&#160;L&quot;\\EFI\\BOOT\\BOOTX64.EFI&quot;</td></tr>
<tr class="separator:a34c834c565bbe0a64cef95edea23f06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8d7ed19541a983ccf869780af80d55"><td class="memItemLeft" align="right" valign="top"><a id="a4e8d7ed19541a983ccf869780af80d55"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EFI_REMOVABLE_MEDIA_FILE_NAME_ARM</b>&#160;&#160;&#160;L&quot;\\EFI\\BOOT\\BOOTARM.EFI&quot;</td></tr>
<tr class="separator:a4e8d7ed19541a983ccf869780af80d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
类型定义</h2></td></tr>
<tr class="memitem:ad33a8459d6a44da25d810961ff655326"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#ad33a8459d6a44da25d810961ff655326">EFI_ALLOCATE_PAGES</a>) (IN <a class="el" href="_uefi_spec_8h.html#aee5e0c5ccb7e884a287da021b444f0c6">EFI_ALLOCATE_TYPE</a> Type, IN <a class="el" href="_uefi_multi_phase_8h.html#a0e2cdd0290e753cca604d3977cbe8bb9">EFI_MEMORY_TYPE</a> MemoryType, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> Pages, IN OUT <a class="el" href="_uefi_base_type_8h.html#a31bc7e7faeab8d2940ee34f21d41cd04">EFI_PHYSICAL_ADDRESS</a> *Memory)</td></tr>
<tr class="separator:ad33a8459d6a44da25d810961ff655326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92f9ee50909bee85d7d8a250d8c1dd3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#ab92f9ee50909bee85d7d8a250d8c1dd3">EFI_FREE_PAGES</a>) (IN <a class="el" href="_uefi_base_type_8h.html#a31bc7e7faeab8d2940ee34f21d41cd04">EFI_PHYSICAL_ADDRESS</a> Memory, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> Pages)</td></tr>
<tr class="separator:ab92f9ee50909bee85d7d8a250d8c1dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a58fcf17f205e9b4ff45fd9b198829a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a6a58fcf17f205e9b4ff45fd9b198829a">EFI_GET_MEMORY_MAP</a>) (IN OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *MemoryMapSize, IN OUT <a class="el" href="struct_e_f_i___m_e_m_o_r_y___d_e_s_c_r_i_p_t_o_r.html">EFI_MEMORY_DESCRIPTOR</a> *MemoryMap, OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *MapKey, OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *DescriptorSize, OUT <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> *DescriptorVersion)</td></tr>
<tr class="separator:a6a58fcf17f205e9b4ff45fd9b198829a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c23204d96680b069775e1d7a779829"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a25c23204d96680b069775e1d7a779829">EFI_ALLOCATE_POOL</a>) (IN <a class="el" href="_uefi_multi_phase_8h.html#a0e2cdd0290e753cca604d3977cbe8bb9">EFI_MEMORY_TYPE</a> PoolType, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> Size, OUT <a class="el" href="interfacevoid.html">VOID</a> **<a class="el" href="class_buffer.html">Buffer</a>)</td></tr>
<tr class="separator:a25c23204d96680b069775e1d7a779829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c3ed96aa1856b59f774df90ba0d6e5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#ad9c3ed96aa1856b59f774df90ba0d6e5">EFI_FREE_POOL</a>) (IN <a class="el" href="interfacevoid.html">VOID</a> *<a class="el" href="class_buffer.html">Buffer</a>)</td></tr>
<tr class="separator:ad9c3ed96aa1856b59f774df90ba0d6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb3bf08a31ab1ea83465b40d8469be5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#accb3bf08a31ab1ea83465b40d8469be5">EFI_SET_VIRTUAL_ADDRESS_MAP</a>) (IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> MemoryMapSize, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> DescriptorSize, IN <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> DescriptorVersion, IN <a class="el" href="struct_e_f_i___m_e_m_o_r_y___d_e_s_c_r_i_p_t_o_r.html">EFI_MEMORY_DESCRIPTOR</a> *VirtualMap)</td></tr>
<tr class="separator:accb3bf08a31ab1ea83465b40d8469be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783ca2b09f5bfa720b9dd5e8bb16a557"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a783ca2b09f5bfa720b9dd5e8bb16a557">EFI_CONNECT_CONTROLLER</a>) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> *DriverImageHandle, OPTIONAL IN <a class="el" href="struct_e_f_i___d_e_v_i_c_e___p_a_t_h___p_r_o_t_o_c_o_l.html">EFI_DEVICE_PATH_PROTOCOL</a> *RemainingDevicePath, OPTIONAL IN <a class="el" href="_processor_bind_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> Recursive)</td></tr>
<tr class="separator:a783ca2b09f5bfa720b9dd5e8bb16a557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d967b7810ca12e3d0c0c6c1e1cfe39e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a2d967b7810ca12e3d0c0c6c1e1cfe39e">EFI_DISCONNECT_CONTROLLER</a>) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> DriverImageHandle, OPTIONAL IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ChildHandle OPTIONAL)</td></tr>
<tr class="separator:a2d967b7810ca12e3d0c0c6c1e1cfe39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fa51da724d04c62403db30446ef211"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a73fa51da724d04c62403db30446ef211">EFI_CONVERT_POINTER</a>) (IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> DebugDisposition, IN OUT <a class="el" href="interfacevoid.html">VOID</a> **Address)</td></tr>
<tr class="separator:a73fa51da724d04c62403db30446ef211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca9ae93c85ccde1ddaeee99053eb2df"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="interfacevoid.html">VOID</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a7ca9ae93c85ccde1ddaeee99053eb2df">EFI_EVENT_NOTIFY</a>) (IN <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> <a class="el" href="struct_event.html">Event</a>, IN <a class="el" href="interfacevoid.html">VOID</a> *<a class="el" href="struct_context.html">Context</a>)</td></tr>
<tr class="separator:a7ca9ae93c85ccde1ddaeee99053eb2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136cb7690540176a224528745133f019"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a136cb7690540176a224528745133f019">EFI_CREATE_EVENT</a>) (IN <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> Type, IN <a class="el" href="_uefi_base_type_8h.html#ab998e5f7da4a664eaa86252ab16e459a">EFI_TPL</a> NotifyTpl, IN <a class="el" href="_uefi_spec_8h.html#a7ca9ae93c85ccde1ddaeee99053eb2df">EFI_EVENT_NOTIFY</a> NotifyFunction, IN <a class="el" href="interfacevoid.html">VOID</a> *NotifyContext, OUT <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> *<a class="el" href="struct_event.html">Event</a>)</td></tr>
<tr class="separator:a136cb7690540176a224528745133f019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fd81bb75ad0d912af92ecae5ae968d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a78fd81bb75ad0d912af92ecae5ae968d">EFI_CREATE_EVENT_EX</a>) (IN <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> Type, IN <a class="el" href="_uefi_base_type_8h.html#ab998e5f7da4a664eaa86252ab16e459a">EFI_TPL</a> NotifyTpl, IN <a class="el" href="_uefi_spec_8h.html#a7ca9ae93c85ccde1ddaeee99053eb2df">EFI_EVENT_NOTIFY</a> NotifyFunction OPTIONAL, IN CONST <a class="el" href="interfacevoid.html">VOID</a> *NotifyContext OPTIONAL, IN CONST <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *EventGroup OPTIONAL, OUT <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> *<a class="el" href="struct_event.html">Event</a>)</td></tr>
<tr class="separator:a78fd81bb75ad0d912af92ecae5ae968d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7517e4b2e50c8f4b07c88651d6b3a4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#afb7517e4b2e50c8f4b07c88651d6b3a4">EFI_SET_TIMER</a>) (IN <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> <a class="el" href="struct_event.html">Event</a>, IN <a class="el" href="_uefi_spec_8h.html#a813f66495f29a8738fc7be0b60076777">EFI_TIMER_DELAY</a> Type, IN <a class="el" href="_processor_bind_8h.html#a57be03562867144161c1bfee95ca8f7c">UINT64</a> TriggerTime)</td></tr>
<tr class="separator:afb7517e4b2e50c8f4b07c88651d6b3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ff2b58c5fcbf0d37c87d336d1475e1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#aa3ff2b58c5fcbf0d37c87d336d1475e1">EFI_SIGNAL_EVENT</a>) (IN <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> <a class="el" href="struct_event.html">Event</a>)</td></tr>
<tr class="separator:aa3ff2b58c5fcbf0d37c87d336d1475e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba96f688dc14bb2154ce5aceb793493"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#aaba96f688dc14bb2154ce5aceb793493">EFI_WAIT_FOR_EVENT</a>) (IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> NumberOfEvents, IN <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> *<a class="el" href="struct_event.html">Event</a>, OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *Index)</td></tr>
<tr class="separator:aaba96f688dc14bb2154ce5aceb793493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeeba9c16cad21f67174de892a51b7f9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#abeeba9c16cad21f67174de892a51b7f9">EFI_CLOSE_EVENT</a>) (IN <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> <a class="el" href="struct_event.html">Event</a>)</td></tr>
<tr class="separator:abeeba9c16cad21f67174de892a51b7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8e6c79edb3a20647fc489d22e329a2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#adf8e6c79edb3a20647fc489d22e329a2">EFI_CHECK_EVENT</a>) (IN <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> <a class="el" href="struct_event.html">Event</a>)</td></tr>
<tr class="separator:adf8e6c79edb3a20647fc489d22e329a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c98857dbe256d29b4000e160e108183"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#ab998e5f7da4a664eaa86252ab16e459a">EFI_TPL</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a9c98857dbe256d29b4000e160e108183">EFI_RAISE_TPL</a>) (IN <a class="el" href="_uefi_base_type_8h.html#ab998e5f7da4a664eaa86252ab16e459a">EFI_TPL</a> NewTpl)</td></tr>
<tr class="separator:a9c98857dbe256d29b4000e160e108183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cf8d8d2257acf2891a645ac7c280c3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="interfacevoid.html">VOID</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a42cf8d8d2257acf2891a645ac7c280c3">EFI_RESTORE_TPL</a>) (IN <a class="el" href="_uefi_base_type_8h.html#ab998e5f7da4a664eaa86252ab16e459a">EFI_TPL</a> OldTpl)</td></tr>
<tr class="separator:a42cf8d8d2257acf2891a645ac7c280c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab046e1f3645995176c1b5fb88a36285"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#aab046e1f3645995176c1b5fb88a36285">EFI_GET_VARIABLE</a>) (IN <a class="el" href="_processor_bind_8h.html#a7ae886893bd2a2ae253eb2b021a48724">CHAR16</a> *VariableName, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *VendorGuid, OUT <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> *Attributes, OPTIONAL IN OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *DataSize, OUT <a class="el" href="interfacevoid.html">VOID</a> *<a class="el" href="struct_data.html">Data</a>)</td></tr>
<tr class="separator:aab046e1f3645995176c1b5fb88a36285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae771f0f8967692958bb016e10e3ecd5c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#ae771f0f8967692958bb016e10e3ecd5c">EFI_GET_NEXT_VARIABLE_NAME</a>) (IN OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *VariableNameSize, IN OUT <a class="el" href="_processor_bind_8h.html#a7ae886893bd2a2ae253eb2b021a48724">CHAR16</a> *VariableName, IN OUT <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *VendorGuid)</td></tr>
<tr class="separator:ae771f0f8967692958bb016e10e3ecd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802f6646c762803fe91a0afdf632ad9f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a802f6646c762803fe91a0afdf632ad9f">EFI_SET_VARIABLE</a>) (IN <a class="el" href="_processor_bind_8h.html#a7ae886893bd2a2ae253eb2b021a48724">CHAR16</a> *VariableName, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *VendorGuid, IN <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> Attributes, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> DataSize, IN <a class="el" href="interfacevoid.html">VOID</a> *<a class="el" href="struct_data.html">Data</a>)</td></tr>
<tr class="separator:a802f6646c762803fe91a0afdf632ad9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6eb46e27b07dfe1e9920806397ba03"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#abf6eb46e27b07dfe1e9920806397ba03">EFI_GET_TIME</a>) (OUT <a class="el" href="struct_e_f_i___t_i_m_e.html">EFI_TIME</a> *Time, OUT <a class="el" href="struct_e_f_i___t_i_m_e___c_a_p_a_b_i_l_i_t_i_e_s.html">EFI_TIME_CAPABILITIES</a> *Capabilities OPTIONAL)</td></tr>
<tr class="separator:abf6eb46e27b07dfe1e9920806397ba03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63632f4d029627e25f33b77a11ef4155"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a63632f4d029627e25f33b77a11ef4155">EFI_SET_TIME</a>) (IN <a class="el" href="struct_e_f_i___t_i_m_e.html">EFI_TIME</a> *Time)</td></tr>
<tr class="separator:a63632f4d029627e25f33b77a11ef4155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35a1e705a27dd772665f0c39d5ab017"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#ae35a1e705a27dd772665f0c39d5ab017">EFI_GET_WAKEUP_TIME</a>) (OUT <a class="el" href="_processor_bind_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> *Enabled, OUT <a class="el" href="_processor_bind_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> *Pending, OUT <a class="el" href="struct_e_f_i___t_i_m_e.html">EFI_TIME</a> *Time)</td></tr>
<tr class="separator:ae35a1e705a27dd772665f0c39d5ab017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf41170aa6f314aaadd5f82a33ab64b7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#acf41170aa6f314aaadd5f82a33ab64b7">EFI_SET_WAKEUP_TIME</a>) (IN <a class="el" href="_processor_bind_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> Enable, IN <a class="el" href="struct_e_f_i___t_i_m_e.html">EFI_TIME</a> *Time OPTIONAL)</td></tr>
<tr class="separator:acf41170aa6f314aaadd5f82a33ab64b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba493f6b693537a86a17e708cfed4d5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a7ba493f6b693537a86a17e708cfed4d5">EFI_IMAGE_LOAD</a>) (IN <a class="el" href="_processor_bind_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> BootPolicy, IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ParentImageHandle, IN <a class="el" href="struct_e_f_i___d_e_v_i_c_e___p_a_t_h___p_r_o_t_o_c_o_l.html">EFI_DEVICE_PATH_PROTOCOL</a> *DevicePath, IN <a class="el" href="interfacevoid.html">VOID</a> *SourceBuffer OPTIONAL, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> SourceSize, OUT <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> *ImageHandle)</td></tr>
<tr class="separator:a7ba493f6b693537a86a17e708cfed4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fe63294031748117705543b1072fdb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a13fe63294031748117705543b1072fdb">EFI_IMAGE_START</a>) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ImageHandle, OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *ExitDataSize, OUT <a class="el" href="_processor_bind_8h.html#a7ae886893bd2a2ae253eb2b021a48724">CHAR16</a> **ExitData OPTIONAL)</td></tr>
<tr class="separator:a13fe63294031748117705543b1072fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5df8cc00a17673494d357d8358c61f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a3e5df8cc00a17673494d357d8358c61f">EFI_EXIT</a>) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ImageHandle, IN <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> ExitStatus, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> ExitDataSize, IN <a class="el" href="_processor_bind_8h.html#a7ae886893bd2a2ae253eb2b021a48724">CHAR16</a> *ExitData OPTIONAL)</td></tr>
<tr class="separator:a3e5df8cc00a17673494d357d8358c61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334c8dd4b1694db0ca13184bc07079f3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a334c8dd4b1694db0ca13184bc07079f3">EFI_IMAGE_UNLOAD</a>) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ImageHandle)</td></tr>
<tr class="separator:a334c8dd4b1694db0ca13184bc07079f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d42888e8b015186256055b5f32e0971"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a8d42888e8b015186256055b5f32e0971">EFI_EXIT_BOOT_SERVICES</a>) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ImageHandle, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> MapKey)</td></tr>
<tr class="separator:a8d42888e8b015186256055b5f32e0971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e4f313eeae5ab1f99ae07f075c51bc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a70e4f313eeae5ab1f99ae07f075c51bc">EFI_STALL</a>) (IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> Microseconds)</td></tr>
<tr class="separator:a70e4f313eeae5ab1f99ae07f075c51bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1480f18f35366fab1598f519a4ea2e0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#aa1480f18f35366fab1598f519a4ea2e0">EFI_SET_WATCHDOG_TIMER</a>) (IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> Timeout, IN <a class="el" href="_processor_bind_8h.html#a57be03562867144161c1bfee95ca8f7c">UINT64</a> WatchdogCode, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> DataSize, IN <a class="el" href="_processor_bind_8h.html#a7ae886893bd2a2ae253eb2b021a48724">CHAR16</a> *WatchdogData OPTIONAL)</td></tr>
<tr class="separator:aa1480f18f35366fab1598f519a4ea2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac49617ff412cb9a78840d6dd35f488"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="interfacevoid.html">VOID</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#acac49617ff412cb9a78840d6dd35f488">EFI_RESET_SYSTEM</a>) (IN <a class="el" href="_uefi_spec_8h.html#aac10574bc0f1e0c24b051d55eb572b49">EFI_RESET_TYPE</a> ResetType, IN <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> ResetStatus, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> DataSize, IN <a class="el" href="interfacevoid.html">VOID</a> *ResetData OPTIONAL)</td></tr>
<tr class="separator:acac49617ff412cb9a78840d6dd35f488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9733322f52dcef83756d8b8e3bd8e6e8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a9733322f52dcef83756d8b8e3bd8e6e8">EFI_GET_NEXT_MONOTONIC_COUNT</a>) (OUT <a class="el" href="_processor_bind_8h.html#a57be03562867144161c1bfee95ca8f7c">UINT64</a> *Count)</td></tr>
<tr class="separator:a9733322f52dcef83756d8b8e3bd8e6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d6a4553d64aad7260f3d60f3ea8e2a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a27d6a4553d64aad7260f3d60f3ea8e2a">EFI_GET_NEXT_HIGH_MONO_COUNT</a>) (OUT <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> *HighCount)</td></tr>
<tr class="separator:a27d6a4553d64aad7260f3d60f3ea8e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2183b05b61adc1527900a3cf45718ef3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a2183b05b61adc1527900a3cf45718ef3">EFI_CALCULATE_CRC32</a>) (IN <a class="el" href="interfacevoid.html">VOID</a> *<a class="el" href="struct_data.html">Data</a>, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> DataSize, OUT <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> *Crc32)</td></tr>
<tr class="separator:a2183b05b61adc1527900a3cf45718ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3afdd15369670fd896e805e866d4db"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="interfacevoid.html">VOID</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a8c3afdd15369670fd896e805e866d4db">EFI_COPY_MEM</a>) (IN <a class="el" href="interfacevoid.html">VOID</a> *Destination, IN <a class="el" href="interfacevoid.html">VOID</a> *Source, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> Length)</td></tr>
<tr class="separator:a8c3afdd15369670fd896e805e866d4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb6ae3021aa8fd3fc0ade1cd51666ba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="interfacevoid.html">VOID</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#aabb6ae3021aa8fd3fc0ade1cd51666ba">EFI_SET_MEM</a>) (IN <a class="el" href="interfacevoid.html">VOID</a> *<a class="el" href="class_buffer.html">Buffer</a>, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> Size, IN <a class="el" href="_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> Value)</td></tr>
<tr class="separator:aabb6ae3021aa8fd3fc0ade1cd51666ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a71b62d2e3a933d91031e98741aeca"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a83a71b62d2e3a933d91031e98741aeca">EFI_INSTALL_PROTOCOL_INTERFACE</a>) (IN OUT <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> *Handle, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, IN <a class="el" href="_uefi_spec_8h.html#a623b3b3bad3799f17b8ded654d7235df">EFI_INTERFACE_TYPE</a> InterfaceType, IN <a class="el" href="interfacevoid.html">VOID</a> *Interface)</td></tr>
<tr class="separator:a83a71b62d2e3a933d91031e98741aeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f07efa92b97aba461dd125c132214c3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a8f07efa92b97aba461dd125c132214c3">EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES</a>) (IN OUT <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> *Handle,...)</td></tr>
<tr class="separator:a8f07efa92b97aba461dd125c132214c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bb898fa0d4c7bc2cbd9fcfd8d3f7ce"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#aa0bb898fa0d4c7bc2cbd9fcfd8d3f7ce">EFI_REINSTALL_PROTOCOL_INTERFACE</a>) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> Handle, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, IN <a class="el" href="interfacevoid.html">VOID</a> *OldInterface, IN <a class="el" href="interfacevoid.html">VOID</a> *NewInterface)</td></tr>
<tr class="separator:aa0bb898fa0d4c7bc2cbd9fcfd8d3f7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9720fc70eb5316876ba3d5f49ca16a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#aac9720fc70eb5316876ba3d5f49ca16a">EFI_UNINSTALL_PROTOCOL_INTERFACE</a>) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> Handle, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, IN <a class="el" href="interfacevoid.html">VOID</a> *Interface)</td></tr>
<tr class="separator:aac9720fc70eb5316876ba3d5f49ca16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801d8cc0f369fdc80b361a0121fa8ce9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a801d8cc0f369fdc80b361a0121fa8ce9">EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES</a>) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> Handle,...)</td></tr>
<tr class="separator:a801d8cc0f369fdc80b361a0121fa8ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8282eb2f5cebea9f023efa015b5906"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a8c8282eb2f5cebea9f023efa015b5906">EFI_HANDLE_PROTOCOL</a>) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> Handle, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, OUT <a class="el" href="interfacevoid.html">VOID</a> **Interface)</td></tr>
<tr class="separator:a8c8282eb2f5cebea9f023efa015b5906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0879485e1bf3136eaf9baa09537c886f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a0879485e1bf3136eaf9baa09537c886f">EFI_OPEN_PROTOCOL</a>) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> Handle, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, OUT <a class="el" href="interfacevoid.html">VOID</a> **Interface, OPTIONAL IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> AgentHandle, IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, IN <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> Attributes)</td></tr>
<tr class="separator:a0879485e1bf3136eaf9baa09537c886f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008f531d3228b8bd9d2caefab2b221c2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a008f531d3228b8bd9d2caefab2b221c2">EFI_CLOSE_PROTOCOL</a>) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> Handle, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> AgentHandle, IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle)</td></tr>
<tr class="separator:a008f531d3228b8bd9d2caefab2b221c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ed9d9f8b9ffa0ce041e82563f9d189"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a07ed9d9f8b9ffa0ce041e82563f9d189">EFI_OPEN_PROTOCOL_INFORMATION</a>) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> Handle, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, OUT <a class="el" href="struct_e_f_i___o_p_e_n___p_r_o_t_o_c_o_l___i_n_f_o_r_m_a_t_i_o_n___e_n_t_r_y.html">EFI_OPEN_PROTOCOL_INFORMATION_ENTRY</a> **EntryBuffer, OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *EntryCount)</td></tr>
<tr class="separator:a07ed9d9f8b9ffa0ce041e82563f9d189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8302604517bb73a9f57ed85a2c056e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a4d8302604517bb73a9f57ed85a2c056e">EFI_PROTOCOLS_PER_HANDLE</a>) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> Handle, OUT <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> ***ProtocolBuffer, OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *ProtocolBufferCount)</td></tr>
<tr class="separator:a4d8302604517bb73a9f57ed85a2c056e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd363625c194ad93f8786cee87a877f7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#afd363625c194ad93f8786cee87a877f7">EFI_REGISTER_PROTOCOL_NOTIFY</a>) (IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, IN <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> <a class="el" href="struct_event.html">Event</a>, OUT <a class="el" href="interfacevoid.html">VOID</a> **Registration)</td></tr>
<tr class="separator:afd363625c194ad93f8786cee87a877f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5429fabf6cbd5f1a19da9f530b3169c9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a5429fabf6cbd5f1a19da9f530b3169c9">EFI_LOCATE_HANDLE</a>) (IN <a class="el" href="_uefi_spec_8h.html#abc5a8a9c636f68115cb3956d6e12e27c">EFI_LOCATE_SEARCH_TYPE</a> SearchType, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, OPTIONAL IN <a class="el" href="interfacevoid.html">VOID</a> *SearchKey, OPTIONAL IN OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *BufferSize, OUT <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> *<a class="el" href="class_buffer.html">Buffer</a>)</td></tr>
<tr class="separator:a5429fabf6cbd5f1a19da9f530b3169c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303e0e1389601ef48d62b1a2c4f9d779"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a303e0e1389601ef48d62b1a2c4f9d779">EFI_LOCATE_DEVICE_PATH</a>) (IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, IN OUT <a class="el" href="struct_e_f_i___d_e_v_i_c_e___p_a_t_h___p_r_o_t_o_c_o_l.html">EFI_DEVICE_PATH_PROTOCOL</a> **DevicePath, OUT <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> *Device)</td></tr>
<tr class="separator:a303e0e1389601ef48d62b1a2c4f9d779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433a7ef4b195848d42f0f3c2732bd61e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a433a7ef4b195848d42f0f3c2732bd61e">EFI_INSTALL_CONFIGURATION_TABLE</a>) (IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *Guid, IN <a class="el" href="interfacevoid.html">VOID</a> *Table)</td></tr>
<tr class="separator:a433a7ef4b195848d42f0f3c2732bd61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b617fafa7624ee2460beae83fe69bc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a16b617fafa7624ee2460beae83fe69bc">EFI_LOCATE_HANDLE_BUFFER</a>) (IN <a class="el" href="_uefi_spec_8h.html#abc5a8a9c636f68115cb3956d6e12e27c">EFI_LOCATE_SEARCH_TYPE</a> SearchType, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, OPTIONAL IN <a class="el" href="interfacevoid.html">VOID</a> *SearchKey, OPTIONAL IN OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *NoHandles, OUT <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> **<a class="el" href="class_buffer.html">Buffer</a>)</td></tr>
<tr class="separator:a16b617fafa7624ee2460beae83fe69bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08f905d14a840760564de80cbef93fb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#ad08f905d14a840760564de80cbef93fb">EFI_LOCATE_PROTOCOL</a>) (IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, IN <a class="el" href="interfacevoid.html">VOID</a> *Registration, OPTIONAL OUT <a class="el" href="interfacevoid.html">VOID</a> **Interface)</td></tr>
<tr class="separator:ad08f905d14a840760564de80cbef93fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948c1bdf15293b20b5c3e4883572dfd2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a948c1bdf15293b20b5c3e4883572dfd2">EFI_UPDATE_CAPSULE</a>) (IN <a class="el" href="struct_e_f_i___c_a_p_s_u_l_e___h_e_a_d_e_r.html">EFI_CAPSULE_HEADER</a> **CapsuleHeaderArray, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> CapsuleCount, IN <a class="el" href="_uefi_base_type_8h.html#a31bc7e7faeab8d2940ee34f21d41cd04">EFI_PHYSICAL_ADDRESS</a> ScatterGatherList OPTIONAL)</td></tr>
<tr class="separator:a948c1bdf15293b20b5c3e4883572dfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb2f2c2c6a036c59b743c5ee261a68a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#adbb2f2c2c6a036c59b743c5ee261a68a">EFI_QUERY_CAPSULE_CAPABILITIES</a>) (IN <a class="el" href="struct_e_f_i___c_a_p_s_u_l_e___h_e_a_d_e_r.html">EFI_CAPSULE_HEADER</a> **CapsuleHeaderArray, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> CapsuleCount, OUT <a class="el" href="_processor_bind_8h.html#a57be03562867144161c1bfee95ca8f7c">UINT64</a> *MaximumCapsuleSize, OUT <a class="el" href="_uefi_spec_8h.html#aac10574bc0f1e0c24b051d55eb572b49">EFI_RESET_TYPE</a> *ResetType)</td></tr>
<tr class="separator:adbb2f2c2c6a036c59b743c5ee261a68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834867b2248041f6bd4de00ca2ea59fa"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a834867b2248041f6bd4de00ca2ea59fa">EFI_QUERY_VARIABLE_INFO</a>) (IN <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> Attributes, OUT <a class="el" href="_processor_bind_8h.html#a57be03562867144161c1bfee95ca8f7c">UINT64</a> *MaximumVariableStorageSize, OUT <a class="el" href="_processor_bind_8h.html#a57be03562867144161c1bfee95ca8f7c">UINT64</a> *RemainingVariableStorageSize, OUT <a class="el" href="_processor_bind_8h.html#a57be03562867144161c1bfee95ca8f7c">UINT64</a> *MaximumVariableSize)</td></tr>
<tr class="separator:a834867b2248041f6bd4de00ca2ea59fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9282a844095b073b19f81510bbde7b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#aad9282a844095b073b19f81510bbde7b">EFI_IMAGE_ENTRY_POINT</a>) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ImageHandle, IN <a class="el" href="struct_e_f_i___s_y_s_t_e_m___t_a_b_l_e.html">EFI_SYSTEM_TABLE</a> *SystemTable)</td></tr>
<tr class="separator:aad9282a844095b073b19f81510bbde7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
枚举</h2></td></tr>
<tr class="memitem:aee5e0c5ccb7e884a287da021b444f0c6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#aee5e0c5ccb7e884a287da021b444f0c6">EFI_ALLOCATE_TYPE</a> { <a class="el" href="_uefi_spec_8h.html#aee5e0c5ccb7e884a287da021b444f0c6aa3885c7caaabe9e43bafbfaae48ca49a">AllocateAnyPages</a>, 
<a class="el" href="_uefi_spec_8h.html#aee5e0c5ccb7e884a287da021b444f0c6a04bb1bb7ae4b90da5ba22d4a19617003">AllocateMaxAddress</a>, 
<a class="el" href="_uefi_spec_8h.html#aee5e0c5ccb7e884a287da021b444f0c6a925be7b9bb228f50488049bcd3343ed8">AllocateAddress</a>, 
<a class="el" href="_uefi_spec_8h.html#aee5e0c5ccb7e884a287da021b444f0c6aa919d7bdd1e81f691e39ca797a850258">MaxAllocateType</a>
 }</td></tr>
<tr class="separator:aee5e0c5ccb7e884a287da021b444f0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813f66495f29a8738fc7be0b60076777"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a813f66495f29a8738fc7be0b60076777">EFI_TIMER_DELAY</a> { <a class="el" href="_uefi_spec_8h.html#a813f66495f29a8738fc7be0b60076777a2c362ea73bc229ab46d950febb9069a5">TimerCancel</a>, 
<a class="el" href="_uefi_spec_8h.html#a813f66495f29a8738fc7be0b60076777ab782ae2f652b671e2a189f237bd4311b">TimerPeriodic</a>, 
<a class="el" href="_uefi_spec_8h.html#a813f66495f29a8738fc7be0b60076777a3ee952465021f14a8514d48f8e4fcceb">TimerRelative</a>
 }</td></tr>
<tr class="separator:a813f66495f29a8738fc7be0b60076777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac10574bc0f1e0c24b051d55eb572b49"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#aac10574bc0f1e0c24b051d55eb572b49">EFI_RESET_TYPE</a> { <a class="el" href="_uefi_spec_8h.html#aac10574bc0f1e0c24b051d55eb572b49a0164249380e07fd1b999f7b611c7fc1b">EfiResetCold</a>, 
<a class="el" href="_uefi_spec_8h.html#aac10574bc0f1e0c24b051d55eb572b49add056ce62c5d63bd742b8ef7d4587c85">EfiResetWarm</a>, 
<a class="el" href="_uefi_spec_8h.html#aac10574bc0f1e0c24b051d55eb572b49ad1b39698e822c87bb227272bb6f791ab">EfiResetShutdown</a>
 }</td></tr>
<tr class="separator:aac10574bc0f1e0c24b051d55eb572b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623b3b3bad3799f17b8ded654d7235df"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#a623b3b3bad3799f17b8ded654d7235df">EFI_INTERFACE_TYPE</a> { <a class="el" href="_uefi_spec_8h.html#a623b3b3bad3799f17b8ded654d7235dfad8699d925d72829d6a475b883be749f3">EFI_NATIVE_INTERFACE</a>
 }</td></tr>
<tr class="separator:a623b3b3bad3799f17b8ded654d7235df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5a8a9c636f68115cb3956d6e12e27c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_uefi_spec_8h.html#abc5a8a9c636f68115cb3956d6e12e27c">EFI_LOCATE_SEARCH_TYPE</a> { <a class="el" href="_uefi_spec_8h.html#abc5a8a9c636f68115cb3956d6e12e27cae5be8a19060f1eee369e4e7c1c473181">AllHandles</a>, 
<a class="el" href="_uefi_spec_8h.html#abc5a8a9c636f68115cb3956d6e12e27cadfb199f4d2c676c2769ea1455c8f27fd">ByRegisterNotify</a>, 
<a class="el" href="_uefi_spec_8h.html#abc5a8a9c636f68115cb3956d6e12e27ca3f1ef40caf6007fd5c451665f1087454">ByProtocol</a>
 }</td></tr>
<tr class="separator:abc5a8a9c636f68115cb3956d6e12e27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>Include file that supports UEFI.</p>
<p><a class="el" href="namespace_this.html">This</a> include file must contain things defined in the UEFI 2.3 specification. If a code construct is defined in the UEFI 2.3 specification it must be included by this include file.</p>
<p>Copyright (c) 2006 - 2012, Intel Corporation. All rights reserved.<br />
 <a class="el" href="namespace_this.html">This</a> program and the accompanying materials are licensed and made available under the terms and conditions of the BSD License that accompanies this distribution. The full text of the license may be found at <a href="http://opensource.org/licenses/bsd-license.php">http://opensource.org/licenses/bsd-license.php</a>.</p>
<p>THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED. </p>
</div><h2 class="groupheader">宏定义说明</h2>
<a id="ac02d5d59fffd00ef796b7e6d33635237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02d5d59fffd00ef796b7e6d33635237">&#9670;&nbsp;</a></span>EFI_MEMORY_DESCRIPTOR_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#<a class="el" href="structdefine.html">define</a> EFI_MEMORY_DESCRIPTOR_VERSION&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memory descriptor version number. </p>

</div>
</div>
<a id="a4896509d679c752bd4bcd474ac66858a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4896509d679c752bd4bcd474ac66858a">&#9670;&nbsp;</a></span>EFI_UNSPECIFIED_TIMEZONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#<a class="el" href="structdefine.html">define</a> EFI_UNSPECIFIED_TIMEZONE&#160;&#160;&#160;0x07FF</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Value definition for EFI_TIME.TimeZone. </p>

</div>
</div>
<h2 class="groupheader">类型定义说明</h2>
<a id="ad33a8459d6a44da25d810961ff655326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33a8459d6a44da25d810961ff655326">&#9670;&nbsp;</a></span>EFI_ALLOCATE_PAGES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_ALLOCATE_PAGES) (IN <a class="el" href="_uefi_spec_8h.html#aee5e0c5ccb7e884a287da021b444f0c6">EFI_ALLOCATE_TYPE</a> Type, IN <a class="el" href="_uefi_multi_phase_8h.html#a0e2cdd0290e753cca604d3977cbe8bb9">EFI_MEMORY_TYPE</a> MemoryType, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> Pages, IN OUT <a class="el" href="_uefi_base_type_8h.html#a31bc7e7faeab8d2940ee34f21d41cd04">EFI_PHYSICAL_ADDRESS</a> *Memory)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates memory pages from the system.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Type</td><td>The type of allocation to perform. </td></tr>
    <tr><td class="paramname">MemoryType</td><td>The type of memory to allocate. </td></tr>
    <tr><td class="paramname">Pages</td><td>The number of contiguous 4 KB pages to allocate. </td></tr>
    <tr><td class="paramname">Memory</td><td>The pointer to a physical address. On input, the way in which the address is used depends on the value of Type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested pages were allocated. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>1) Type is not AllocateAnyPages or AllocateMaxAddress or AllocateAddress. 2) MemoryType is in the range 3) Memory is NULL. EfiMaxMemoryType..0x7FFFFFFF. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The pages could not be allocated. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The requested pages could not be found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25c23204d96680b069775e1d7a779829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c23204d96680b069775e1d7a779829">&#9670;&nbsp;</a></span>EFI_ALLOCATE_POOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_ALLOCATE_POOL) (IN <a class="el" href="_uefi_multi_phase_8h.html#a0e2cdd0290e753cca604d3977cbe8bb9">EFI_MEMORY_TYPE</a> PoolType, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> Size, OUT <a class="el" href="interfacevoid.html">VOID</a> **<a class="el" href="class_buffer.html">Buffer</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates pool memory.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">PoolType</td><td>The type of pool to allocate. </td></tr>
    <tr><td class="paramname">Size</td><td>The number of bytes to allocate from the pool. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_buffer.html">Buffer</a></td><td><a class="el" href="struct_a.html">A</a> pointer to a pointer to the allocated buffer if the call succeeds; undefined otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested number of bytes was allocated. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The pool requested could not be allocated. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>PoolType was invalid or <a class="el" href="class_buffer.html">Buffer</a> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2183b05b61adc1527900a3cf45718ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2183b05b61adc1527900a3cf45718ef3">&#9670;&nbsp;</a></span>EFI_CALCULATE_CRC32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_CALCULATE_CRC32) (IN <a class="el" href="interfacevoid.html">VOID</a> *<a class="el" href="struct_data.html">Data</a>, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> DataSize, OUT <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> *Crc32)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes and returns a 32-bit CRC for a data buffer.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="struct_data.html">Data</a></td><td><a class="el" href="struct_a.html">A</a> pointer to the buffer on which the 32-bit CRC is to be computed. </td></tr>
    <tr><td class="paramname">DataSize</td><td>The number of bytes in the buffer <a class="el" href="struct_data.html">Data</a>. </td></tr>
    <tr><td class="paramname">Crc32</td><td>The 32-bit CRC that was computed for the data buffer specified by <a class="el" href="struct_data.html">Data</a> and DataSize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The 32-bit CRC was computed for the data buffer and returned in Crc32. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td><a class="el" href="struct_data.html">Data</a> is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Crc32 is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DataSize is 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf8e6c79edb3a20647fc489d22e329a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8e6c79edb3a20647fc489d22e329a2">&#9670;&nbsp;</a></span>EFI_CHECK_EVENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_CHECK_EVENT) (IN <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> <a class="el" href="struct_event.html">Event</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether an event is in the signaled state.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="struct_event.html">Event</a></td><td>The event to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The event is in the signaled state. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The event is not in the signaled state. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td><a class="el" href="struct_event.html">Event</a> is of type EVT_NOTIFY_SIGNAL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abeeba9c16cad21f67174de892a51b7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeeba9c16cad21f67174de892a51b7f9">&#9670;&nbsp;</a></span>EFI_CLOSE_EVENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_CLOSE_EVENT) (IN <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> <a class="el" href="struct_event.html">Event</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes an event.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="struct_event.html">Event</a></td><td>The event to close.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The event has been closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a008f531d3228b8bd9d2caefab2b221c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008f531d3228b8bd9d2caefab2b221c2">&#9670;&nbsp;</a></span>EFI_CLOSE_PROTOCOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_CLOSE_PROTOCOL) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> Handle, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> AgentHandle, IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes a protocol on a handle that was opened using OpenProtocol().</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Handle</td><td>The handle for the protocol interface that was previously opened with OpenProtocol(), and is now being closed. </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_protocol.html">Protocol</a></td><td>The published unique identifier of the protocol. </td></tr>
    <tr><td class="paramname">AgentHandle</td><td>The handle of the agent that is closing the protocol interface. </td></tr>
    <tr><td class="paramname">ControllerHandle</td><td>If the agent that opened a protocol is a driver that follows the UEFI Driver Model, then this parameter is the controller handle that required the protocol interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The protocol instance was closed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>1) Handle is NULL. 2) AgentHandle is NULL. 3) ControllerHandle is not NULL and ControllerHandle is not a valid EFI_HANDLE. 4) <a class="el" href="struct_protocol.html">Protocol</a> is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>1) Handle does not support the protocol specified by <a class="el" href="struct_protocol.html">Protocol</a>. 2) The protocol interface specified by Handle and <a class="el" href="struct_protocol.html">Protocol</a> is not currently open by AgentHandle and ControllerHandle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a783ca2b09f5bfa720b9dd5e8bb16a557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783ca2b09f5bfa720b9dd5e8bb16a557">&#9670;&nbsp;</a></span>EFI_CONNECT_CONTROLLER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_CONNECT_CONTROLLER) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> *DriverImageHandle, OPTIONAL IN <a class="el" href="struct_e_f_i___d_e_v_i_c_e___p_a_t_h___p_r_o_t_o_c_o_l.html">EFI_DEVICE_PATH_PROTOCOL</a> *RemainingDevicePath, OPTIONAL IN <a class="el" href="_processor_bind_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> Recursive)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects one or more drivers to a controller.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ControllerHandle</td><td>The handle of the controller to which driver(s) are to be connected. </td></tr>
    <tr><td class="paramname">DriverImageHandle</td><td><a class="el" href="struct_a.html">A</a> pointer to an ordered list handles that support the EFI_DRIVER_BINDING_PROTOCOL. </td></tr>
    <tr><td class="paramname">RemainingDevicePath</td><td><a class="el" href="struct_a.html">A</a> pointer to the device path that specifies a child of the controller specified by ControllerHandle. </td></tr>
    <tr><td class="paramname">Recursive</td><td>If TRUE, then ConnectController() is called recursively until the entire tree of controllers below the controller specified by ControllerHandle have been created. If FALSE, then the tree of controllers is only expanded one level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>1) One or more drivers were connected to ControllerHandle. 2) No drivers were connected to ControllerHandle, but RemainingDevicePath is not NULL, and it is an End Device Path Node. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ControllerHandle is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>1) There are no EFI_DRIVER_BINDING_PROTOCOL instances present in the system. 2) No drivers were connected to ControllerHandle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73fa51da724d04c62403db30446ef211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fa51da724d04c62403db30446ef211">&#9670;&nbsp;</a></span>EFI_CONVERT_POINTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_CONVERT_POINTER) (IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> DebugDisposition, IN OUT <a class="el" href="interfacevoid.html">VOID</a> **Address)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the new virtual address that is to be used on subsequent memory accesses.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">DebugDisposition</td><td>Supplies type information for the pointer being converted. </td></tr>
    <tr><td class="paramname">Address</td><td><a class="el" href="struct_a.html">A</a> pointer to a pointer that is to be fixed to be the value needed for the new virtual address mappings being applied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The pointer pointed to by Address was modified. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>1) Address is NULL. 2) *Address is NULL and DebugDisposition does not have the EFI_OPTIONAL_PTR bit set. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The pointer pointed to by Address was not found to be part of the current memory map. <a class="el" href="namespace_this.html">This</a> is normally fatal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c3afdd15369670fd896e805e866d4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3afdd15369670fd896e805e866d4db">&#9670;&nbsp;</a></span>EFI_COPY_MEM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="interfacevoid.html">VOID</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_COPY_MEM) (IN <a class="el" href="interfacevoid.html">VOID</a> *Destination, IN <a class="el" href="interfacevoid.html">VOID</a> *Source, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> Length)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the contents of one buffer to another buffer.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Destination</td><td>The pointer to the destination buffer of the memory copy. </td></tr>
    <tr><td class="paramname">Source</td><td>The pointer to the source buffer of the memory copy. </td></tr>
    <tr><td class="paramname">Length</td><td>Number of bytes to copy from Source to Destination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a136cb7690540176a224528745133f019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136cb7690540176a224528745133f019">&#9670;&nbsp;</a></span>EFI_CREATE_EVENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_CREATE_EVENT) (IN <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> Type, IN <a class="el" href="_uefi_base_type_8h.html#ab998e5f7da4a664eaa86252ab16e459a">EFI_TPL</a> NotifyTpl, IN <a class="el" href="_uefi_spec_8h.html#a7ca9ae93c85ccde1ddaeee99053eb2df">EFI_EVENT_NOTIFY</a> NotifyFunction, IN <a class="el" href="interfacevoid.html">VOID</a> *NotifyContext, OUT <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> *<a class="el" href="struct_event.html">Event</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an event.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Type</td><td>The type of event to create and its mode and attributes. </td></tr>
    <tr><td class="paramname">NotifyTpl</td><td>The task priority level of event notifications, if needed. </td></tr>
    <tr><td class="paramname">NotifyFunction</td><td>The pointer to the event's notification function, if any. </td></tr>
    <tr><td class="paramname">NotifyContext</td><td>The pointer to the notification function's context; corresponds to parameter <a class="el" href="struct_context.html">Context</a> in the notification function. </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_event.html">Event</a></td><td>The pointer to the newly created event if the call succeeds; undefined otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The event structure was created. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more parameters are invalid. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The event could not be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78fd81bb75ad0d912af92ecae5ae968d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fd81bb75ad0d912af92ecae5ae968d">&#9670;&nbsp;</a></span>EFI_CREATE_EVENT_EX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_CREATE_EVENT_EX) (IN <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> Type, IN <a class="el" href="_uefi_base_type_8h.html#ab998e5f7da4a664eaa86252ab16e459a">EFI_TPL</a> NotifyTpl, IN <a class="el" href="_uefi_spec_8h.html#a7ca9ae93c85ccde1ddaeee99053eb2df">EFI_EVENT_NOTIFY</a> NotifyFunction OPTIONAL, IN CONST <a class="el" href="interfacevoid.html">VOID</a> *NotifyContext OPTIONAL, IN CONST <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *EventGroup OPTIONAL, OUT <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> *<a class="el" href="struct_event.html">Event</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an event in a group.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Type</td><td>The type of event to create and its mode and attributes. </td></tr>
    <tr><td class="paramname">NotifyTpl</td><td>The task priority level of event notifications,if needed. </td></tr>
    <tr><td class="paramname">NotifyFunction</td><td>The pointer to the event's notification function, if any. </td></tr>
    <tr><td class="paramname">NotifyContext</td><td>The pointer to the notification function's context; corresponds to parameter <a class="el" href="struct_context.html">Context</a> in the notification function. </td></tr>
    <tr><td class="paramname">EventGroup</td><td>The pointer to the unique identifier of the group to which this event belongs. If this is NULL, then the function behaves as if the parameters were passed to CreateEvent. </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_event.html">Event</a></td><td>The pointer to the newly created event if the call succeeds; undefined otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The event structure was created. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more parameters are invalid. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The event could not be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d967b7810ca12e3d0c0c6c1e1cfe39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d967b7810ca12e3d0c0c6c1e1cfe39e">&#9670;&nbsp;</a></span>EFI_DISCONNECT_CONTROLLER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_DISCONNECT_CONTROLLER) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> DriverImageHandle, OPTIONAL IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ChildHandle OPTIONAL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disconnects one or more drivers from a controller.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ControllerHandle</td><td>The handle of the controller from which driver(s) are to be disconnected. </td></tr>
    <tr><td class="paramname">DriverImageHandle</td><td>The driver to disconnect from ControllerHandle. If DriverImageHandle is NULL, then all the drivers currently managing ControllerHandle are disconnected from ControllerHandle. </td></tr>
    <tr><td class="paramname">ChildHandle</td><td>The handle of the child to destroy. If ChildHandle is NULL, then all the children of ControllerHandle are destroyed before the drivers are disconnected from ControllerHandle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>1) One or more drivers were disconnected from the controller. 2) On entry, no drivers are managing ControllerHandle. 3) DriverImageHandle is not NULL, and on entry DriverImageHandle is not managing ControllerHandle. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>1) ControllerHandle is NULL. 2) DriverImageHandle is not NULL, and it is not a valid EFI_HANDLE. 3) ChildHandle is not NULL, and it is not a valid EFI_HANDLE. 4) DriverImageHandle does not support the EFI_DRIVER_BINDING_PROTOCOL. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There are not enough resources available to disconnect any drivers from ControllerHandle. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The controller could not be disconnected because of a device error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ca9ae93c85ccde1ddaeee99053eb2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca9ae93c85ccde1ddaeee99053eb2df">&#9670;&nbsp;</a></span>EFI_EVENT_NOTIFY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="interfacevoid.html">VOID</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_EVENT_NOTIFY) (IN <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> <a class="el" href="struct_event.html">Event</a>, IN <a class="el" href="interfacevoid.html">VOID</a> *<a class="el" href="struct_context.html">Context</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invoke a notification event</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="struct_event.html">Event</a></td><td><a class="el" href="struct_event.html">Event</a> whose notification function is being invoked. </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_context.html">Context</a></td><td>The pointer to the notification function's context, which is implementation-dependent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e5df8cc00a17673494d357d8358c61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5df8cc00a17673494d357d8358c61f">&#9670;&nbsp;</a></span>EFI_EXIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_EXIT) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ImageHandle, IN <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> ExitStatus, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> ExitDataSize, IN <a class="el" href="_processor_bind_8h.html#a7ae886893bd2a2ae253eb2b021a48724">CHAR16</a> *ExitData OPTIONAL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Terminates a loaded EFI image and returns control to boot services.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ImageHandle</td><td>Handle that identifies the image. <a class="el" href="namespace_this.html">This</a> parameter is passed to the image on entry. </td></tr>
    <tr><td class="paramname">ExitStatus</td><td>The image's exit code. </td></tr>
    <tr><td class="paramname">ExitDataSize</td><td>The size, in bytes, of ExitData. Ignored if ExitStatus is EFI_SUCCESS. </td></tr>
    <tr><td class="paramname">ExitData</td><td>The pointer to a data buffer that includes a Null-terminated string, optionally followed by additional binary data. The string is a description that the caller may use to further indicate the reason for the image's exit. ExitData is only valid if ExitStatus is something other than EFI_SUCCESS. The ExitData buffer must be allocated by calling AllocatePool().</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The image specified by ImageHandle was unloaded. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The image specified by ImageHandle has been loaded and started with LoadImage() and StartImage(), but the image is not the currently executing image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d42888e8b015186256055b5f32e0971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d42888e8b015186256055b5f32e0971">&#9670;&nbsp;</a></span>EFI_EXIT_BOOT_SERVICES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_EXIT_BOOT_SERVICES) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ImageHandle, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> MapKey)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Terminates all boot services.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ImageHandle</td><td>Handle that identifies the exiting image. </td></tr>
    <tr><td class="paramname">MapKey</td><td><a class="el" href="struct_key.html">Key</a> to the latest memory map.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Boot services have been terminated. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>MapKey is incorrect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab92f9ee50909bee85d7d8a250d8c1dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92f9ee50909bee85d7d8a250d8c1dd3">&#9670;&nbsp;</a></span>EFI_FREE_PAGES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_FREE_PAGES) (IN <a class="el" href="_uefi_base_type_8h.html#a31bc7e7faeab8d2940ee34f21d41cd04">EFI_PHYSICAL_ADDRESS</a> Memory, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> Pages)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees memory pages.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Memory</td><td>The base physical address of the pages to be freed. </td></tr>
    <tr><td class="paramname">Pages</td><td>The number of contiguous 4 KB pages to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The requested pages were freed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Memory is not a page-aligned address or Pages is invalid. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The requested memory pages were not allocated with AllocatePages(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9c3ed96aa1856b59f774df90ba0d6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c3ed96aa1856b59f774df90ba0d6e5">&#9670;&nbsp;</a></span>EFI_FREE_POOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_FREE_POOL) (IN <a class="el" href="interfacevoid.html">VOID</a> *<a class="el" href="class_buffer.html">Buffer</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns pool memory to the system.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="class_buffer.html">Buffer</a></td><td>The pointer to the buffer to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The memory was returned to the system. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td><a class="el" href="class_buffer.html">Buffer</a> was invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a58fcf17f205e9b4ff45fd9b198829a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a58fcf17f205e9b4ff45fd9b198829a">&#9670;&nbsp;</a></span>EFI_GET_MEMORY_MAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_GET_MEMORY_MAP) (IN OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *MemoryMapSize, IN OUT <a class="el" href="struct_e_f_i___m_e_m_o_r_y___d_e_s_c_r_i_p_t_o_r.html">EFI_MEMORY_DESCRIPTOR</a> *MemoryMap, OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *MapKey, OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *DescriptorSize, OUT <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> *DescriptorVersion)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current memory map.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">MemoryMapSize</td><td><a class="el" href="struct_a.html">A</a> pointer to the size, in bytes, of the MemoryMap buffer. On input, this is the size of the buffer allocated by the caller. On output, it is the size of the buffer returned by the firmware if the buffer was large enough, or the size of the buffer needed to contain the map if the buffer was too small. </td></tr>
    <tr><td class="paramname">MemoryMap</td><td><a class="el" href="struct_a.html">A</a> pointer to the buffer in which firmware places the current memory map. </td></tr>
    <tr><td class="paramname">MapKey</td><td><a class="el" href="struct_a.html">A</a> pointer to the location in which firmware returns the key for the current memory map. </td></tr>
    <tr><td class="paramname">DescriptorSize</td><td><a class="el" href="struct_a.html">A</a> pointer to the location in which firmware returns the size, in bytes, of an individual <a class="el" href="struct_e_f_i___m_e_m_o_r_y___d_e_s_c_r_i_p_t_o_r.html">EFI_MEMORY_DESCRIPTOR</a>. </td></tr>
    <tr><td class="paramname">DescriptorVersion</td><td><a class="el" href="struct_a.html">A</a> pointer to the location in which firmware returns the version number associated with the <a class="el" href="struct_e_f_i___m_e_m_o_r_y___d_e_s_c_r_i_p_t_o_r.html">EFI_MEMORY_DESCRIPTOR</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The memory map was returned in the MemoryMap buffer. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The MemoryMap buffer was too small. The current buffer size needed to hold the memory map is returned in MemoryMapSize. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>1) MemoryMapSize is NULL. 2) The MemoryMap buffer is not too small and MemoryMap is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27d6a4553d64aad7260f3d60f3ea8e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d6a4553d64aad7260f3d60f3ea8e2a">&#9670;&nbsp;</a></span>EFI_GET_NEXT_HIGH_MONO_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_GET_NEXT_HIGH_MONO_COUNT) (OUT <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> *HighCount)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the next high 32 bits of the platform's monotonic counter.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">HighCount</td><td>The pointer to returned value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The next high monotonic count was returned. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>HighCount is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device is not functioning properly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9733322f52dcef83756d8b8e3bd8e6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9733322f52dcef83756d8b8e3bd8e6e8">&#9670;&nbsp;</a></span>EFI_GET_NEXT_MONOTONIC_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_GET_NEXT_MONOTONIC_COUNT) (OUT <a class="el" href="_processor_bind_8h.html#a57be03562867144161c1bfee95ca8f7c">UINT64</a> *Count)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a monotonically increasing count for the platform.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>The pointer to returned value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The next monotonic count was returned. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Count is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device is not functioning properly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae771f0f8967692958bb016e10e3ecd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae771f0f8967692958bb016e10e3ecd5c">&#9670;&nbsp;</a></span>EFI_GET_NEXT_VARIABLE_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_GET_NEXT_VARIABLE_NAME) (IN OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *VariableNameSize, IN OUT <a class="el" href="_processor_bind_8h.html#a7ae886893bd2a2ae253eb2b021a48724">CHAR16</a> *VariableName, IN OUT <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *VendorGuid)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumerates the current variable names.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">VariableNameSize</td><td>The size of the VariableName buffer. </td></tr>
    <tr><td class="paramname">VariableName</td><td>On input, supplies the last VariableName that was returned by GetNextVariableName(). On output, returns the Nullterminated string of the current variable. </td></tr>
    <tr><td class="paramname">VendorGuid</td><td>On input, supplies the last VendorGuid that was returned by GetNextVariableName(). On output, returns the VendorGuid of the current variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function completed successfully. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The next variable was not found. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The VariableNameSize is too small for the result. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>VariableNameSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>VariableName is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>VendorGuid is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The variable could not be retrieved due to a hardware error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf6eb46e27b07dfe1e9920806397ba03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6eb46e27b07dfe1e9920806397ba03">&#9670;&nbsp;</a></span>EFI_GET_TIME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_GET_TIME) (OUT <a class="el" href="struct_e_f_i___t_i_m_e.html">EFI_TIME</a> *Time, OUT <a class="el" href="struct_e_f_i___t_i_m_e___c_a_p_a_b_i_l_i_t_i_e_s.html">EFI_TIME_CAPABILITIES</a> *Capabilities OPTIONAL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current time and date information, and the time-keeping capabilities of the hardware platform.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Time</td><td><a class="el" href="struct_a.html">A</a> pointer to storage to receive a snapshot of the current time. </td></tr>
    <tr><td class="paramname">Capabilities</td><td>An optional pointer to a buffer to receive the real time clock device's capabilities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Time is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The time could not be retrieved due to hardware error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab046e1f3645995176c1b5fb88a36285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab046e1f3645995176c1b5fb88a36285">&#9670;&nbsp;</a></span>EFI_GET_VARIABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_GET_VARIABLE) (IN <a class="el" href="_processor_bind_8h.html#a7ae886893bd2a2ae253eb2b021a48724">CHAR16</a> *VariableName, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *VendorGuid, OUT <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> *Attributes, OPTIONAL IN OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *DataSize, OUT <a class="el" href="interfacevoid.html">VOID</a> *<a class="el" href="struct_data.html">Data</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value of a variable.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">VariableName</td><td><a class="el" href="struct_a.html">A</a> Null-terminated string that is the name of the vendor's variable. </td></tr>
    <tr><td class="paramname">VendorGuid</td><td><a class="el" href="struct_a.html">A</a> unique identifier for the vendor. </td></tr>
    <tr><td class="paramname">Attributes</td><td>If not NULL, a pointer to the memory location to return the attributes bitmask for the variable. </td></tr>
    <tr><td class="paramname">DataSize</td><td>On input, the size in bytes of the return <a class="el" href="struct_data.html">Data</a> buffer. On output the size of data returned in <a class="el" href="struct_data.html">Data</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_data.html">Data</a></td><td>The buffer to return the contents of the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The function completed successfully. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The variable was not found. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The DataSize is too small for the result. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>VariableName is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>VendorGuid is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DataSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The DataSize is not too small and <a class="el" href="struct_data.html">Data</a> is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The variable could not be retrieved due to a hardware error. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>The variable could not be retrieved due to an authentication failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae35a1e705a27dd772665f0c39d5ab017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35a1e705a27dd772665f0c39d5ab017">&#9670;&nbsp;</a></span>EFI_GET_WAKEUP_TIME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_GET_WAKEUP_TIME) (OUT <a class="el" href="_processor_bind_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> *Enabled, OUT <a class="el" href="_processor_bind_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> *Pending, OUT <a class="el" href="struct_e_f_i___t_i_m_e.html">EFI_TIME</a> *Time)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current wakeup alarm clock setting.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Enabled</td><td>Indicates if the alarm is currently enabled or disabled. </td></tr>
    <tr><td class="paramname">Pending</td><td>Indicates if the alarm signal is pending and requires acknowledgement. </td></tr>
    <tr><td class="paramname">Time</td><td>The current alarm setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The alarm settings were returned. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Enabled is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Pending is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Time is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The wakeup time could not be retrieved due to a hardware error. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td><a class="el" href="struct_a.html">A</a> wakeup timer is not supported on this platform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c8282eb2f5cebea9f023efa015b5906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8282eb2f5cebea9f023efa015b5906">&#9670;&nbsp;</a></span>EFI_HANDLE_PROTOCOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_HANDLE_PROTOCOL) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> Handle, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, OUT <a class="el" href="interfacevoid.html">VOID</a> **Interface)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries a handle to determine if it supports a specified protocol.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Handle</td><td>The handle being queried. </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_protocol.html">Protocol</a></td><td>The published unique identifier of the protocol. </td></tr>
    <tr><td class="paramname">Interface</td><td>Supplies the address where a pointer to the corresponding <a class="el" href="struct_protocol.html">Protocol</a> Interface is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The interface information for the specified protocol was returned. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The device does not support the specified protocol. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Handle is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td><a class="el" href="struct_protocol.html">Protocol</a> is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Interface is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad9282a844095b073b19f81510bbde7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9282a844095b073b19f81510bbde7b">&#9670;&nbsp;</a></span>EFI_IMAGE_ENTRY_POINT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_IMAGE_ENTRY_POINT) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ImageHandle, IN <a class="el" href="struct_e_f_i___s_y_s_t_e_m___t_a_b_l_e.html">EFI_SYSTEM_TABLE</a> *SystemTable)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespace_this.html">This</a> is the declaration of an EFI image entry point. <a class="el" href="namespace_this.html">This</a> entry point is the same for UEFI Applications, UEFI OS Loaders, and UEFI Drivers including both device drivers and bus drivers.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ImageHandle</td><td>The firmware allocated handle for the UEFI image. </td></tr>
    <tr><td class="paramname">SystemTable</td><td><a class="el" href="struct_a.html">A</a> pointer to the EFI System Table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">Others</td><td>An unexpected error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ba493f6b693537a86a17e708cfed4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba493f6b693537a86a17e708cfed4d5">&#9670;&nbsp;</a></span>EFI_IMAGE_LOAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_IMAGE_LOAD) (IN <a class="el" href="_processor_bind_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> BootPolicy, IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ParentImageHandle, IN <a class="el" href="struct_e_f_i___d_e_v_i_c_e___p_a_t_h___p_r_o_t_o_c_o_l.html">EFI_DEVICE_PATH_PROTOCOL</a> *DevicePath, IN <a class="el" href="interfacevoid.html">VOID</a> *SourceBuffer OPTIONAL, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> SourceSize, OUT <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> *ImageHandle)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads an EFI image into memory.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">BootPolicy</td><td>If TRUE, indicates that the request originates from the boot manager, and that the boot manager is attempting to load FilePath as a boot selection. Ignored if SourceBuffer is not NULL. </td></tr>
    <tr><td class="paramname">ParentImageHandle</td><td>The caller's image handle. </td></tr>
    <tr><td class="paramname">DevicePath</td><td>The DeviceHandle specific file path from which the image is loaded. </td></tr>
    <tr><td class="paramname">SourceBuffer</td><td>If not NULL, a pointer to the memory location containing a copy of the image to be loaded. </td></tr>
    <tr><td class="paramname">SourceSize</td><td>The size in bytes of SourceBuffer. Ignored if SourceBuffer is NULL. </td></tr>
    <tr><td class="paramname">ImageHandle</td><td>The pointer to the returned image handle that is created when the image is successfully loaded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td><a class="el" href="class_image.html">Image</a> was loaded into memory correctly. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Both SourceBuffer and DevicePath are NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more parametes are invalid. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The image type is not supported. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td><a class="el" href="class_image.html">Image</a> was not loaded due to insufficient resources. </td></tr>
    <tr><td class="paramname">EFI_LOAD_ERROR</td><td><a class="el" href="class_image.html">Image</a> was not loaded because the image format was corrupt or not understood. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td><a class="el" href="class_image.html">Image</a> was not loaded because the device returned a read error. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td><a class="el" href="class_image.html">Image</a> was not loaded because the platform policy prohibits the image from being loaded. NULL is returned in *ImageHandle. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td><a class="el" href="class_image.html">Image</a> was loaded and an ImageHandle was created with a valid <a class="el" href="struct_e_f_i___l_o_a_d_e_d___i_m_a_g_e___p_r_o_t_o_c_o_l.html">EFI_LOADED_IMAGE_PROTOCOL</a>. However, the current platform policy specifies that the image should not be started. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13fe63294031748117705543b1072fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fe63294031748117705543b1072fdb">&#9670;&nbsp;</a></span>EFI_IMAGE_START</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_IMAGE_START) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ImageHandle, OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *ExitDataSize, OUT <a class="el" href="_processor_bind_8h.html#a7ae886893bd2a2ae253eb2b021a48724">CHAR16</a> **ExitData OPTIONAL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfers control to a loaded image's entry point.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ImageHandle</td><td>Handle of image to be started. </td></tr>
    <tr><td class="paramname">ExitDataSize</td><td>The pointer to the size, in bytes, of ExitData. </td></tr>
    <tr><td class="paramname">ExitData</td><td>The pointer to a pointer to a data buffer that includes a Null-terminated string, optionally followed by additional binary data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ImageHandle is either an invalid image handle or the image has already been initialized with StartImage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Exit code from image </dd></dl>

</div>
</div>
<a id="a334c8dd4b1694db0ca13184bc07079f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334c8dd4b1694db0ca13184bc07079f3">&#9670;&nbsp;</a></span>EFI_IMAGE_UNLOAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_IMAGE_UNLOAD) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ImageHandle)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unloads an image.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ImageHandle</td><td>Handle that identifies the image to be unloaded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The image has been unloaded. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ImageHandle is not a valid image handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a433a7ef4b195848d42f0f3c2732bd61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433a7ef4b195848d42f0f3c2732bd61e">&#9670;&nbsp;</a></span>EFI_INSTALL_CONFIGURATION_TABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_INSTALL_CONFIGURATION_TABLE) (IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *Guid, IN <a class="el" href="interfacevoid.html">VOID</a> *Table)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds, updates, or removes a configuration table entry from the EFI System Table.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Guid</td><td><a class="el" href="struct_a.html">A</a> pointer to the <a class="el" href="interface_g_u_i_d.html">GUID</a> for the entry to add, update, or remove. </td></tr>
    <tr><td class="paramname">Table</td><td><a class="el" href="struct_a.html">A</a> pointer to the configuration table for the entry to add, update, or remove. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The (Guid, Table) pair was added, updated, or removed. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>An attempt was made to delete a nonexistent entry. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Guid is NULL. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There is not enough memory available to complete the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f07efa92b97aba461dd125c132214c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f07efa92b97aba461dd125c132214c3">&#9670;&nbsp;</a></span>EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES) (IN OUT <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> *Handle,...)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Installs one or more protocol interfaces into the boot services environment.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Handle</td><td>The handle to install the new protocol interfaces on, or NULL if a new handle is to be allocated. </td></tr>
    <tr><td class="paramname">...</td><td><a class="el" href="struct_a.html">A</a> variable argument list containing pairs of protocol GUIDs and protocol interfaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>All the protocol interface was installed. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There was not enough memory in pool to install all the protocols. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td><a class="el" href="struct_a.html">A</a> Device Path <a class="el" href="struct_protocol.html">Protocol</a> instance was passed in that is already present in the handle database. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83a71b62d2e3a933d91031e98741aeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a71b62d2e3a933d91031e98741aeca">&#9670;&nbsp;</a></span>EFI_INSTALL_PROTOCOL_INTERFACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_INSTALL_PROTOCOL_INTERFACE) (IN OUT <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> *Handle, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, IN <a class="el" href="_uefi_spec_8h.html#a623b3b3bad3799f17b8ded654d7235df">EFI_INTERFACE_TYPE</a> InterfaceType, IN <a class="el" href="interfacevoid.html">VOID</a> *Interface)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Installs a protocol interface on a device handle. If the handle does not exist, it is created and added to the list of handles in the system. InstallMultipleProtocolInterfaces() performs more error checking than InstallProtocolInterface(), so it is recommended that InstallMultipleProtocolInterfaces() be used in place of InstallProtocolInterface()</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Handle</td><td><a class="el" href="struct_a.html">A</a> pointer to the EFI_HANDLE on which the interface is to be installed. </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_protocol.html">Protocol</a></td><td>The numeric ID of the protocol interface. </td></tr>
    <tr><td class="paramname">InterfaceType</td><td>Indicates whether Interface is supplied in native form. </td></tr>
    <tr><td class="paramname">Interface</td><td><a class="el" href="struct_a.html">A</a> pointer to the protocol interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The protocol interface was installed. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Space for a new handle could not be allocated. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Handle is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td><a class="el" href="struct_protocol.html">Protocol</a> is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>InterfaceType is not EFI_NATIVE_INTERFACE. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td><a class="el" href="struct_protocol.html">Protocol</a> is already installed on the handle specified by Handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a303e0e1389601ef48d62b1a2c4f9d779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303e0e1389601ef48d62b1a2c4f9d779">&#9670;&nbsp;</a></span>EFI_LOCATE_DEVICE_PATH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_LOCATE_DEVICE_PATH) (IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, IN OUT <a class="el" href="struct_e_f_i___d_e_v_i_c_e___p_a_t_h___p_r_o_t_o_c_o_l.html">EFI_DEVICE_PATH_PROTOCOL</a> **DevicePath, OUT <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> *Device)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locates the handle to a device on the device path that supports the specified protocol.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="struct_protocol.html">Protocol</a></td><td>Specifies the protocol to search for. </td></tr>
    <tr><td class="paramname">DevicePath</td><td>On input, a pointer to a pointer to the device path. On output, the device path pointer is modified to point to the remaining part of the device path. </td></tr>
    <tr><td class="paramname">Device</td><td><a class="el" href="struct_a.html">A</a> pointer to the returned device handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The resulting handle was returned. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>No handles match the search. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td><a class="el" href="struct_protocol.html">Protocol</a> is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DevicePath is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td><a class="el" href="struct_a.html">A</a> handle matched the search and Device is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5429fabf6cbd5f1a19da9f530b3169c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5429fabf6cbd5f1a19da9f530b3169c9">&#9670;&nbsp;</a></span>EFI_LOCATE_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_LOCATE_HANDLE) (IN <a class="el" href="_uefi_spec_8h.html#abc5a8a9c636f68115cb3956d6e12e27c">EFI_LOCATE_SEARCH_TYPE</a> SearchType, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, OPTIONAL IN <a class="el" href="interfacevoid.html">VOID</a> *SearchKey, OPTIONAL IN OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *BufferSize, OUT <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> *<a class="el" href="class_buffer.html">Buffer</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an array of handles that support a specified protocol.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">SearchType</td><td>Specifies which <a class="el" href="structhandle.html">handle(s)</a> are to be returned. </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_protocol.html">Protocol</a></td><td>Specifies the protocol to search by. </td></tr>
    <tr><td class="paramname">SearchKey</td><td>Specifies the search key. </td></tr>
    <tr><td class="paramname">BufferSize</td><td>On input, the size in bytes of <a class="el" href="class_buffer.html">Buffer</a>. On output, the size in bytes of the array returned in <a class="el" href="class_buffer.html">Buffer</a> (if the buffer was large enough) or the size, in bytes, of the buffer needed to obtain the array (if the buffer was not large enough). </td></tr>
    <tr><td class="paramname"><a class="el" href="class_buffer.html">Buffer</a></td><td>The buffer in which the array is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The array of handles was returned. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>No handles match the search. </td></tr>
    <tr><td class="paramname">EFI_BUFFER_TOO_SMALL</td><td>The BufferSize is too small for the result. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>SearchType is not a member of EFI_LOCATE_SEARCH_TYPE. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>SearchType is ByRegisterNotify and SearchKey is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>SearchType is ByProtocol and <a class="el" href="struct_protocol.html">Protocol</a> is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more matches are found and BufferSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>BufferSize is large enough for the result and <a class="el" href="class_buffer.html">Buffer</a> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16b617fafa7624ee2460beae83fe69bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b617fafa7624ee2460beae83fe69bc">&#9670;&nbsp;</a></span>EFI_LOCATE_HANDLE_BUFFER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_LOCATE_HANDLE_BUFFER) (IN <a class="el" href="_uefi_spec_8h.html#abc5a8a9c636f68115cb3956d6e12e27c">EFI_LOCATE_SEARCH_TYPE</a> SearchType, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, OPTIONAL IN <a class="el" href="interfacevoid.html">VOID</a> *SearchKey, OPTIONAL IN OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *NoHandles, OUT <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> **<a class="el" href="class_buffer.html">Buffer</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an array of handles that support the requested protocol in a buffer allocated from pool.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">SearchType</td><td>Specifies which <a class="el" href="structhandle.html">handle(s)</a> are to be returned. </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_protocol.html">Protocol</a></td><td>Provides the protocol to search by. <a class="el" href="namespace_this.html">This</a> parameter is only valid for a SearchType of ByProtocol. </td></tr>
    <tr><td class="paramname">SearchKey</td><td>Supplies the search key depending on the SearchType. </td></tr>
    <tr><td class="paramname">NoHandles</td><td>The number of handles returned in <a class="el" href="class_buffer.html">Buffer</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_buffer.html">Buffer</a></td><td><a class="el" href="struct_a.html">A</a> pointer to the buffer to return the requested array of handles that support <a class="el" href="struct_protocol.html">Protocol</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The array of handles was returned in <a class="el" href="class_buffer.html">Buffer</a>, and the number of handles in <a class="el" href="class_buffer.html">Buffer</a> was returned in NoHandles. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>No handles match the search. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There is not enough pool memory to store the matching results. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>NoHandles is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td><a class="el" href="class_buffer.html">Buffer</a> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad08f905d14a840760564de80cbef93fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08f905d14a840760564de80cbef93fb">&#9670;&nbsp;</a></span>EFI_LOCATE_PROTOCOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_LOCATE_PROTOCOL) (IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, IN <a class="el" href="interfacevoid.html">VOID</a> *Registration, OPTIONAL OUT <a class="el" href="interfacevoid.html">VOID</a> **Interface)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the first protocol instance that matches the given protocol.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="struct_protocol.html">Protocol</a></td><td>Provides the protocol to search for. </td></tr>
    <tr><td class="paramname">Registration</td><td>Optional registration key returned from RegisterProtocolNotify(). </td></tr>
    <tr><td class="paramname">Interface</td><td>On return, a pointer to the first interface that matches <a class="el" href="struct_protocol.html">Protocol</a> and Registration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td><a class="el" href="struct_a.html">A</a> protocol instance matching <a class="el" href="struct_protocol.html">Protocol</a> was found and returned in Interface. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>No protocol instances were found that match <a class="el" href="struct_protocol.html">Protocol</a> and Registration. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Interface is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0879485e1bf3136eaf9baa09537c886f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0879485e1bf3136eaf9baa09537c886f">&#9670;&nbsp;</a></span>EFI_OPEN_PROTOCOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_OPEN_PROTOCOL) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> Handle, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, OUT <a class="el" href="interfacevoid.html">VOID</a> **Interface, OPTIONAL IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> AgentHandle, IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, IN <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> Attributes)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries a handle to determine if it supports a specified protocol. If the protocol is supported by the handle, it opens the protocol on behalf of the calling agent.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Handle</td><td>The handle for the protocol interface that is being opened. </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_protocol.html">Protocol</a></td><td>The published unique identifier of the protocol. </td></tr>
    <tr><td class="paramname">Interface</td><td>Supplies the address where a pointer to the corresponding <a class="el" href="struct_protocol.html">Protocol</a> Interface is returned. </td></tr>
    <tr><td class="paramname">AgentHandle</td><td>The handle of the agent that is opening the protocol interface specified by <a class="el" href="struct_protocol.html">Protocol</a> and Interface. </td></tr>
    <tr><td class="paramname">ControllerHandle</td><td>If the agent that is opening a protocol is a driver that follows the UEFI Driver Model, then this parameter is the controller handle that requires the protocol interface. If the agent does not follow the UEFI Driver Model, then this parameter is optional and may be NULL. </td></tr>
    <tr><td class="paramname">Attributes</td><td>The open mode of the protocol interface specified by Handle and <a class="el" href="struct_protocol.html">Protocol</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>An item was added to the open list for the protocol interface, and the protocol interface was returned in Interface. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Handle does not support <a class="el" href="struct_protocol.html">Protocol</a>. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more parameters are invalid. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>Required attributes can't be supported in current environment. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>Item on the open list already has requierd attributes whose agent handle is the same as AgentHandle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07ed9d9f8b9ffa0ce041e82563f9d189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ed9d9f8b9ffa0ce041e82563f9d189">&#9670;&nbsp;</a></span>EFI_OPEN_PROTOCOL_INFORMATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_OPEN_PROTOCOL_INFORMATION) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> Handle, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, OUT <a class="el" href="struct_e_f_i___o_p_e_n___p_r_o_t_o_c_o_l___i_n_f_o_r_m_a_t_i_o_n___e_n_t_r_y.html">EFI_OPEN_PROTOCOL_INFORMATION_ENTRY</a> **EntryBuffer, OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *EntryCount)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the list of agents that currently have a protocol interface opened.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Handle</td><td>The handle for the protocol interface that is being queried. </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_protocol.html">Protocol</a></td><td>The published unique identifier of the protocol. </td></tr>
    <tr><td class="paramname">EntryBuffer</td><td><a class="el" href="struct_a.html">A</a> pointer to a buffer of open protocol information in the form of <a class="el" href="struct_e_f_i___o_p_e_n___p_r_o_t_o_c_o_l___i_n_f_o_r_m_a_t_i_o_n___e_n_t_r_y.html">EFI_OPEN_PROTOCOL_INFORMATION_ENTRY</a> structures. </td></tr>
    <tr><td class="paramname">EntryCount</td><td><a class="el" href="struct_a.html">A</a> pointer to the number of entries in EntryBuffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The open protocol information was returned in EntryBuffer, and the number of entries was returned EntryCount. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There are not enough resources available to allocate EntryBuffer. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Handle does not support the protocol specified by <a class="el" href="struct_protocol.html">Protocol</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d8302604517bb73a9f57ed85a2c056e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8302604517bb73a9f57ed85a2c056e">&#9670;&nbsp;</a></span>EFI_PROTOCOLS_PER_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_PROTOCOLS_PER_HANDLE) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> Handle, OUT <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> ***ProtocolBuffer, OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *ProtocolBufferCount)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the list of protocol interface GUIDs that are installed on a handle in a buffer allocated from pool.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Handle</td><td>The handle from which to retrieve the list of protocol interface GUIDs. </td></tr>
    <tr><td class="paramname">ProtocolBuffer</td><td><a class="el" href="struct_a.html">A</a> pointer to the list of protocol interface <a class="el" href="interface_g_u_i_d.html">GUID</a> pointers that are installed on Handle. </td></tr>
    <tr><td class="paramname">ProtocolBufferCount</td><td><a class="el" href="struct_a.html">A</a> pointer to the number of <a class="el" href="interface_g_u_i_d.html">GUID</a> pointers present in ProtocolBuffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The list of protocol interface GUIDs installed on Handle was returned in ProtocolBuffer. The number of protocol interface GUIDs was returned in ProtocolBufferCount. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There is not enough pool memory to store the results. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Handle is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Handle is not a valid EFI_HANDLE. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProtocolBuffer is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProtocolBufferCount is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbb2f2c2c6a036c59b743c5ee261a68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb2f2c2c6a036c59b743c5ee261a68a">&#9670;&nbsp;</a></span>EFI_QUERY_CAPSULE_CAPABILITIES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_QUERY_CAPSULE_CAPABILITIES) (IN <a class="el" href="struct_e_f_i___c_a_p_s_u_l_e___h_e_a_d_e_r.html">EFI_CAPSULE_HEADER</a> **CapsuleHeaderArray, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> CapsuleCount, OUT <a class="el" href="_processor_bind_8h.html#a57be03562867144161c1bfee95ca8f7c">UINT64</a> *MaximumCapsuleSize, OUT <a class="el" href="_uefi_spec_8h.html#aac10574bc0f1e0c24b051d55eb572b49">EFI_RESET_TYPE</a> *ResetType)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if the capsule can be supported via UpdateCapsule().</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">CapsuleHeaderArray</td><td>Virtual pointer to an array of virtual pointers to the capsules being passed into update capsule. </td></tr>
    <tr><td class="paramname">CapsuleCount</td><td>Number of pointers to <a class="el" href="struct_e_f_i___c_a_p_s_u_l_e___h_e_a_d_e_r.html">EFI_CAPSULE_HEADER</a> in CaspuleHeaderArray. </td></tr>
    <tr><td class="paramname">MaxiumCapsuleSize</td><td>On output the maximum size that UpdateCapsule() can support as an argument to UpdateCapsule() via CapsuleHeaderArray and ScatterGatherList. </td></tr>
    <tr><td class="paramname">ResetType</td><td>Returns the type of reset required for the capsule update.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Valid answer returned. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The capsule type is not supported on this platform, and MaximumCapsuleSize and ResetType are undefined. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>MaximumCapsuleSize is NULL. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There were insufficient resources to process the query request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a834867b2248041f6bd4de00ca2ea59fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834867b2248041f6bd4de00ca2ea59fa">&#9670;&nbsp;</a></span>EFI_QUERY_VARIABLE_INFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_QUERY_VARIABLE_INFO) (IN <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> Attributes, OUT <a class="el" href="_processor_bind_8h.html#a57be03562867144161c1bfee95ca8f7c">UINT64</a> *MaximumVariableStorageSize, OUT <a class="el" href="_processor_bind_8h.html#a57be03562867144161c1bfee95ca8f7c">UINT64</a> *RemainingVariableStorageSize, OUT <a class="el" href="_processor_bind_8h.html#a57be03562867144161c1bfee95ca8f7c">UINT64</a> *MaximumVariableSize)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns information about the EFI variables.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Attributes</td><td>Attributes bitmask to specify the type of variables on which to return information. </td></tr>
    <tr><td class="paramname">MaximumVariableStorageSize</td><td>On output the maximum size of the storage space available for the EFI variables associated with the attributes specified. </td></tr>
    <tr><td class="paramname">RemainingVariableStorageSize</td><td>Returns the remaining size of the storage space available for the EFI variables associated with the attributes specified. </td></tr>
    <tr><td class="paramname">MaximumVariableSize</td><td>Returns the maximum size of the individual EFI variables associated with the attributes specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Valid answer returned. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>An invalid combination of attribute bits was supplied </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The attribute is not supported on this platform, and the MaximumVariableStorageSize, RemainingVariableStorageSize, MaximumVariableSize are undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c98857dbe256d29b4000e160e108183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c98857dbe256d29b4000e160e108183">&#9670;&nbsp;</a></span>EFI_RAISE_TPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#ab998e5f7da4a664eaa86252ab16e459a">EFI_TPL</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_RAISE_TPL) (IN <a class="el" href="_uefi_base_type_8h.html#ab998e5f7da4a664eaa86252ab16e459a">EFI_TPL</a> NewTpl)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Raises a task's priority level and returns its previous level.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewTpl</td><td>The new task priority level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Previous task priority level </dd></dl>

</div>
</div>
<a id="afd363625c194ad93f8786cee87a877f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd363625c194ad93f8786cee87a877f7">&#9670;&nbsp;</a></span>EFI_REGISTER_PROTOCOL_NOTIFY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_REGISTER_PROTOCOL_NOTIFY) (IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, IN <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> <a class="el" href="struct_event.html">Event</a>, OUT <a class="el" href="interfacevoid.html">VOID</a> **Registration)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an event that is to be signaled whenever an interface is installed for a specified protocol.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="struct_protocol.html">Protocol</a></td><td>The numeric ID of the protocol for which the event is to be registered. </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_event.html">Event</a></td><td><a class="el" href="struct_event.html">Event</a> that is to be signaled whenever a protocol interface is registered for <a class="el" href="struct_protocol.html">Protocol</a>. </td></tr>
    <tr><td class="paramname">Registration</td><td><a class="el" href="struct_a.html">A</a> pointer to a memory location to receive the registration value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The notification event has been registered. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Space for the notification event could not be allocated. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td><a class="el" href="struct_protocol.html">Protocol</a> is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td><a class="el" href="struct_event.html">Event</a> is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Registration is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0bb898fa0d4c7bc2cbd9fcfd8d3f7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bb898fa0d4c7bc2cbd9fcfd8d3f7ce">&#9670;&nbsp;</a></span>EFI_REINSTALL_PROTOCOL_INTERFACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_REINSTALL_PROTOCOL_INTERFACE) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> Handle, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, IN <a class="el" href="interfacevoid.html">VOID</a> *OldInterface, IN <a class="el" href="interfacevoid.html">VOID</a> *NewInterface)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinstalls a protocol interface on a device handle.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Handle</td><td>Handle on which the interface is to be reinstalled. </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_protocol.html">Protocol</a></td><td>The numeric ID of the interface. </td></tr>
    <tr><td class="paramname">OldInterface</td><td><a class="el" href="struct_a.html">A</a> pointer to the old interface. NULL can be used if a structure is not associated with <a class="el" href="struct_protocol.html">Protocol</a>. </td></tr>
    <tr><td class="paramname">NewInterface</td><td><a class="el" href="struct_a.html">A</a> pointer to the new interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The protocol interface was reinstalled. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The OldInterface on the handle was not found. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The protocol interface could not be reinstalled, because OldInterface is still being used by a driver that will not release it. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Handle is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td><a class="el" href="struct_protocol.html">Protocol</a> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acac49617ff412cb9a78840d6dd35f488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac49617ff412cb9a78840d6dd35f488">&#9670;&nbsp;</a></span>EFI_RESET_SYSTEM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="interfacevoid.html">VOID</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_RESET_SYSTEM) (IN <a class="el" href="_uefi_spec_8h.html#aac10574bc0f1e0c24b051d55eb572b49">EFI_RESET_TYPE</a> ResetType, IN <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> ResetStatus, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> DataSize, IN <a class="el" href="interfacevoid.html">VOID</a> *ResetData OPTIONAL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the entire platform.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ResetType</td><td>The type of reset to perform. </td></tr>
    <tr><td class="paramname">ResetStatus</td><td>The status code for the reset. </td></tr>
    <tr><td class="paramname">DataSize</td><td>The size, in bytes, of WatchdogData. </td></tr>
    <tr><td class="paramname">ResetData</td><td>For a ResetType of EfiResetCold, EfiResetWarm, or EfiResetShutdown the data buffer starts with a Null-terminated string, optionally followed by additional binary data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42cf8d8d2257acf2891a645ac7c280c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42cf8d8d2257acf2891a645ac7c280c3">&#9670;&nbsp;</a></span>EFI_RESTORE_TPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="interfacevoid.html">VOID</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_RESTORE_TPL) (IN <a class="el" href="_uefi_base_type_8h.html#ab998e5f7da4a664eaa86252ab16e459a">EFI_TPL</a> OldTpl)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restores a task's priority level to its previous value.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">OldTpl</td><td>The previous task priority level to restore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabb6ae3021aa8fd3fc0ade1cd51666ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb6ae3021aa8fd3fc0ade1cd51666ba">&#9670;&nbsp;</a></span>EFI_SET_MEM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="interfacevoid.html">VOID</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_SET_MEM) (IN <a class="el" href="interfacevoid.html">VOID</a> *<a class="el" href="class_buffer.html">Buffer</a>, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> Size, IN <a class="el" href="_processor_bind_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> Value)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The SetMem() function fills a buffer with a specified value.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="class_buffer.html">Buffer</a></td><td>The pointer to the buffer to fill. </td></tr>
    <tr><td class="paramname">Size</td><td>Number of bytes in <a class="el" href="class_buffer.html">Buffer</a> to fill. </td></tr>
    <tr><td class="paramname">Value</td><td>Value to fill <a class="el" href="class_buffer.html">Buffer</a> with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63632f4d029627e25f33b77a11ef4155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63632f4d029627e25f33b77a11ef4155">&#9670;&nbsp;</a></span>EFI_SET_TIME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_SET_TIME) (IN <a class="el" href="struct_e_f_i___t_i_m_e.html">EFI_TIME</a> *Time)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the current local time and date information.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Time</td><td><a class="el" href="struct_a.html">A</a> pointer to the current time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The operation completed successfully. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td><a class="el" href="struct_a.html">A</a> time field is out of range. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The time could not be set due due to hardware error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb7517e4b2e50c8f4b07c88651d6b3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7517e4b2e50c8f4b07c88651d6b3a4">&#9670;&nbsp;</a></span>EFI_SET_TIMER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_SET_TIMER) (IN <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> <a class="el" href="struct_event.html">Event</a>, IN <a class="el" href="_uefi_spec_8h.html#a813f66495f29a8738fc7be0b60076777">EFI_TIMER_DELAY</a> Type, IN <a class="el" href="_processor_bind_8h.html#a57be03562867144161c1bfee95ca8f7c">UINT64</a> TriggerTime)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the type of timer and the trigger time for a timer event.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="struct_event.html">Event</a></td><td>The timer event that is to be signaled at the specified time. </td></tr>
    <tr><td class="paramname">Type</td><td>The type of time that is specified in TriggerTime. </td></tr>
    <tr><td class="paramname">TriggerTime</td><td>The number of 100ns units until the timer expires. <a class="el" href="struct_a.html">A</a> TriggerTime of 0 is legal. If Type is TimerRelative and TriggerTime is 0, then the timer event will be signaled on the next timer tick. If Type is TimerPeriodic and TriggerTime is 0, then the timer event will be signaled on every timer tick.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The event has been set to be signaled at the requested time. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td><a class="el" href="struct_event.html">Event</a> or Type is not valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a802f6646c762803fe91a0afdf632ad9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802f6646c762803fe91a0afdf632ad9f">&#9670;&nbsp;</a></span>EFI_SET_VARIABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_SET_VARIABLE) (IN <a class="el" href="_processor_bind_8h.html#a7ae886893bd2a2ae253eb2b021a48724">CHAR16</a> *VariableName, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *VendorGuid, IN <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> Attributes, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> DataSize, IN <a class="el" href="interfacevoid.html">VOID</a> *<a class="el" href="struct_data.html">Data</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the value of a variable.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">VariableName</td><td><a class="el" href="struct_a.html">A</a> Null-terminated string that is the name of the vendor's variable. Each VariableName is unique for each VendorGuid. VariableName must contain 1 or more characters. If VariableName is an empty string, then EFI_INVALID_PARAMETER is returned. </td></tr>
    <tr><td class="paramname">VendorGuid</td><td><a class="el" href="struct_a.html">A</a> unique identifier for the vendor. </td></tr>
    <tr><td class="paramname">Attributes</td><td>Attributes bitmask to set for the variable. </td></tr>
    <tr><td class="paramname">DataSize</td><td>The size in bytes of the <a class="el" href="struct_data.html">Data</a> buffer. <a class="el" href="struct_a.html">A</a> size of zero causes the variable to be deleted. </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_data.html">Data</a></td><td>The contents for the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The firmware has successfully stored the variable and its data as defined by the Attributes. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>An invalid combination of attribute bits was supplied, or the DataSize exceeds the maximum allowed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>VariableName is an empty string. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>Not enough storage is available to hold the variable and its data. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The variable could not be retrieved due to a hardware error. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The variable in question is read-only. </td></tr>
    <tr><td class="paramname">EFI_WRITE_PROTECTED</td><td>The variable in question cannot be deleted. </td></tr>
    <tr><td class="paramname">EFI_SECURITY_VIOLATION</td><td>The variable could not be written due to EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS set but the AuthInfo does NOT pass the validation check carried out by the firmware. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The variable trying to be updated or deleted was not found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accb3bf08a31ab1ea83465b40d8469be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb3bf08a31ab1ea83465b40d8469be5">&#9670;&nbsp;</a></span>EFI_SET_VIRTUAL_ADDRESS_MAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_SET_VIRTUAL_ADDRESS_MAP) (IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> MemoryMapSize, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> DescriptorSize, IN <a class="el" href="_processor_bind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> DescriptorVersion, IN <a class="el" href="struct_e_f_i___m_e_m_o_r_y___d_e_s_c_r_i_p_t_o_r.html">EFI_MEMORY_DESCRIPTOR</a> *VirtualMap)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the runtime addressing mode of EFI firmware from physical to virtual.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">MemoryMapSize</td><td>The size in bytes of VirtualMap. </td></tr>
    <tr><td class="paramname">DescriptorSize</td><td>The size in bytes of an entry in the VirtualMap. </td></tr>
    <tr><td class="paramname">DescriptorVersion</td><td>The version of the structure entries in VirtualMap. </td></tr>
    <tr><td class="paramname">VirtualMap</td><td>An array of memory descriptors which contain new virtual address mapping information for all runtime ranges.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The virtual address map has been applied. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>EFI firmware is not at runtime, or the EFI firmware is already in virtual address mapped mode. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>DescriptorSize or DescriptorVersion is invalid. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td><a class="el" href="struct_a.html">A</a> virtual address was not supplied for a range in the memory map that requires a mapping. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td><a class="el" href="struct_a.html">A</a> virtual address was supplied for an address that is not found in the memory map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf41170aa6f314aaadd5f82a33ab64b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf41170aa6f314aaadd5f82a33ab64b7">&#9670;&nbsp;</a></span>EFI_SET_WAKEUP_TIME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_SET_WAKEUP_TIME) (IN <a class="el" href="_processor_bind_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> Enable, IN <a class="el" href="struct_e_f_i___t_i_m_e.html">EFI_TIME</a> *Time OPTIONAL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the system wakeup alarm clock time.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Enabled</td><td>Enable or disable the wakeup alarm. </td></tr>
    <tr><td class="paramname">Time</td><td>If Enable is TRUE, the time to set the wakeup alarm for. If Enable is FALSE, then this parameter is optional, and may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>If Enable is TRUE, then the wakeup alarm was enabled. If Enable is FALSE, then the wakeup alarm was disabled. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td><a class="el" href="struct_a.html">A</a> time field is out of range. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The wakeup time could not be set due to a hardware error. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td><a class="el" href="struct_a.html">A</a> wakeup timer is not supported on this platform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1480f18f35366fab1598f519a4ea2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1480f18f35366fab1598f519a4ea2e0">&#9670;&nbsp;</a></span>EFI_SET_WATCHDOG_TIMER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_SET_WATCHDOG_TIMER) (IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> Timeout, IN <a class="el" href="_processor_bind_8h.html#a57be03562867144161c1bfee95ca8f7c">UINT64</a> WatchdogCode, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> DataSize, IN <a class="el" href="_processor_bind_8h.html#a7ae886893bd2a2ae253eb2b021a48724">CHAR16</a> *WatchdogData OPTIONAL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the system's watchdog timer.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Timeout</td><td>The number of seconds to set the watchdog timer to. </td></tr>
    <tr><td class="paramname">WatchdogCode</td><td>The numeric code to log on a watchdog timer timeout event. </td></tr>
    <tr><td class="paramname">DataSize</td><td>The size, in bytes, of WatchdogData. </td></tr>
    <tr><td class="paramname">WatchdogData</td><td><a class="el" href="struct_a.html">A</a> data buffer that includes a Null-terminated string, optionally followed by additional binary data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The timeout has been set. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The supplied WatchdogCode is invalid. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The system does not have a watchdog timer. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The watchdog timer could not be programmed due to a hardware error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3ff2b58c5fcbf0d37c87d336d1475e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ff2b58c5fcbf0d37c87d336d1475e1">&#9670;&nbsp;</a></span>EFI_SIGNAL_EVENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_SIGNAL_EVENT) (IN <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> <a class="el" href="struct_event.html">Event</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signals an event.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="struct_event.html">Event</a></td><td>The event to signal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The event has been signaled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70e4f313eeae5ab1f99ae07f075c51bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e4f313eeae5ab1f99ae07f075c51bc">&#9670;&nbsp;</a></span>EFI_STALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_STALL) (IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> Microseconds)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Induces a fine-grained stall.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Microseconds</td><td>The number of microseconds to stall execution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Execution was stalled at least the requested number of Microseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a801d8cc0f369fdc80b361a0121fa8ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801d8cc0f369fdc80b361a0121fa8ce9">&#9670;&nbsp;</a></span>EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> Handle,...)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes one or more protocol interfaces into the boot services environment.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Handle</td><td>The handle to remove the protocol interfaces from. </td></tr>
    <tr><td class="paramname">...</td><td><a class="el" href="struct_a.html">A</a> variable argument list containing pairs of protocol GUIDs and protocol interfaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>All the protocol interfaces were removed. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One of the protocol interfaces was not previously installed on Handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac9720fc70eb5316876ba3d5f49ca16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9720fc70eb5316876ba3d5f49ca16a">&#9670;&nbsp;</a></span>EFI_UNINSTALL_PROTOCOL_INTERFACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_UNINSTALL_PROTOCOL_INTERFACE) (IN <a class="el" href="_uefi_base_type_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> Handle, IN <a class="el" href="_uefi_base_type_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> *<a class="el" href="struct_protocol.html">Protocol</a>, IN <a class="el" href="interfacevoid.html">VOID</a> *Interface)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a protocol interface from a device handle. <a class="el" href="class_it.html">It</a> is recommended that UninstallMultipleProtocolInterfaces() be used in place of UninstallProtocolInterface().</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Handle</td><td>The handle on which the interface was installed. </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_protocol.html">Protocol</a></td><td>The numeric ID of the interface. </td></tr>
    <tr><td class="paramname">Interface</td><td><a class="el" href="struct_a.html">A</a> pointer to the interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The interface was removed. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The interface was not found. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The interface was not removed because the interface is still being used by a driver. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Handle is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td><a class="el" href="struct_protocol.html">Protocol</a> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a948c1bdf15293b20b5c3e4883572dfd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948c1bdf15293b20b5c3e4883572dfd2">&#9670;&nbsp;</a></span>EFI_UPDATE_CAPSULE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_UPDATE_CAPSULE) (IN <a class="el" href="struct_e_f_i___c_a_p_s_u_l_e___h_e_a_d_e_r.html">EFI_CAPSULE_HEADER</a> **CapsuleHeaderArray, IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> CapsuleCount, IN <a class="el" href="_uefi_base_type_8h.html#a31bc7e7faeab8d2940ee34f21d41cd04">EFI_PHYSICAL_ADDRESS</a> ScatterGatherList OPTIONAL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Passes capsules to the firmware with both virtual and physical mapping. Depending on the intended consumption, the firmware may process the capsule immediately. If the payload should persist across a system reset, the reset value returned from EFI_QueryCapsuleCapabilities must be passed into ResetSystem() and will cause the capsule to be processed by the firmware as part of the reset process.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">CapsuleHeaderArray</td><td>Virtual pointer to an array of virtual pointers to the capsules being passed into update capsule. </td></tr>
    <tr><td class="paramname">CapsuleCount</td><td>Number of pointers to <a class="el" href="struct_e_f_i___c_a_p_s_u_l_e___h_e_a_d_e_r.html">EFI_CAPSULE_HEADER</a> in CaspuleHeaderArray. </td></tr>
    <tr><td class="paramname">ScatterGatherList</td><td>Physical pointer to a set of <a class="el" href="struct_e_f_i___c_a_p_s_u_l_e___b_l_o_c_k___d_e_s_c_r_i_p_t_o_r.html">EFI_CAPSULE_BLOCK_DESCRIPTOR</a> that describes the location in physical memory of a set of capsules.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Valid capsule was passed. If CAPSULE_FLAGS_PERSIT_ACROSS_RESET is not set, the capsule has been successfully processed by the firmware. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CapsuleSize is NULL, or an incompatible set of flags were set in the capsule header. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>CapsuleCount is 0. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The capsule update was started, but failed due to a device error. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The capsule type is not supported on this platform. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>There were insufficient resources to process the capsule. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba96f688dc14bb2154ce5aceb793493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba96f688dc14bb2154ce5aceb793493">&#9670;&nbsp;</a></span>EFI_WAIT_FOR_EVENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_uefi_base_type_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="_processor_bind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_WAIT_FOR_EVENT) (IN <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> NumberOfEvents, IN <a class="el" href="_uefi_base_type_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> *<a class="el" href="struct_event.html">Event</a>, OUT <a class="el" href="_processor_bind_8h.html#ac0b1ca9b01db611e0f7f2080a2699135">UINTN</a> *Index)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops execution until an event is signaled.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumberOfEvents</td><td>The number of events in the <a class="el" href="struct_event.html">Event</a> array. </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_event.html">Event</a></td><td>An array of EFI_EVENT. </td></tr>
    <tr><td class="paramname">Index</td><td>The pointer to the index of the event which satisfied the wait condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The event indicated by Index was signaled. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>1) NumberOfEvents is 0. 2) The event indicated by Index is of type EVT_NOTIFY_SIGNAL. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The current TPL is not TPL_APPLICATION. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">枚举类型说明</h2>
<a id="aee5e0c5ccb7e884a287da021b444f0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5e0c5ccb7e884a287da021b444f0c6">&#9670;&nbsp;</a></span>EFI_ALLOCATE_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceenum.html">enum</a> <a class="el" href="_uefi_spec_8h.html#aee5e0c5ccb7e884a287da021b444f0c6">EFI_ALLOCATE_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI memory allocation types. </p>
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="aee5e0c5ccb7e884a287da021b444f0c6aa3885c7caaabe9e43bafbfaae48ca49a"></a>AllocateAnyPages&#160;</td><td class="fielddoc"><p>Allocate any available range of pages that satisfies the request. </p>
</td></tr>
<tr><td class="fieldname"><a id="aee5e0c5ccb7e884a287da021b444f0c6a04bb1bb7ae4b90da5ba22d4a19617003"></a>AllocateMaxAddress&#160;</td><td class="fielddoc"><p>Allocate any available range of pages whose uppermost address is less than or equal to a specified maximum address. </p>
</td></tr>
<tr><td class="fieldname"><a id="aee5e0c5ccb7e884a287da021b444f0c6a925be7b9bb228f50488049bcd3343ed8"></a>AllocateAddress&#160;</td><td class="fielddoc"><p>Allocate pages at a specified address. </p>
</td></tr>
<tr><td class="fieldname"><a id="aee5e0c5ccb7e884a287da021b444f0c6aa919d7bdd1e81f691e39ca797a850258"></a>MaxAllocateType&#160;</td><td class="fielddoc"><p>Maximum enumeration value that may be used for bounds checking. </p>
</td></tr>
</table>

</div>
</div>
<a id="a623b3b3bad3799f17b8ded654d7235df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623b3b3bad3799f17b8ded654d7235df">&#9670;&nbsp;</a></span>EFI_INTERFACE_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceenum.html">enum</a> <a class="el" href="_uefi_spec_8h.html#a623b3b3bad3799f17b8ded654d7235df">EFI_INTERFACE_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI Interface Types </p>
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="a623b3b3bad3799f17b8ded654d7235dfad8699d925d72829d6a475b883be749f3"></a>EFI_NATIVE_INTERFACE&#160;</td><td class="fielddoc"><p>Indicates that the supplied protocol interface is supplied in native form. </p>
</td></tr>
</table>

</div>
</div>
<a id="abc5a8a9c636f68115cb3956d6e12e27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5a8a9c636f68115cb3956d6e12e27c">&#9670;&nbsp;</a></span>EFI_LOCATE_SEARCH_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceenum.html">enum</a> <a class="el" href="_uefi_spec_8h.html#abc5a8a9c636f68115cb3956d6e12e27c">EFI_LOCATE_SEARCH_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of EFI Locate Search Types </p>
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="abc5a8a9c636f68115cb3956d6e12e27cae5be8a19060f1eee369e4e7c1c473181"></a>AllHandles&#160;</td><td class="fielddoc"><p>Retrieve all the handles in the handle database. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc5a8a9c636f68115cb3956d6e12e27cadfb199f4d2c676c2769ea1455c8f27fd"></a>ByRegisterNotify&#160;</td><td class="fielddoc"><p>Retrieve the next handle fron a RegisterProtocolNotify() event. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc5a8a9c636f68115cb3956d6e12e27ca3f1ef40caf6007fd5c451665f1087454"></a>ByProtocol&#160;</td><td class="fielddoc"><p>Retrieve the set of handles from the handle database that support a specified protocol. </p>
</td></tr>
</table>

</div>
</div>
<a id="aac10574bc0f1e0c24b051d55eb572b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac10574bc0f1e0c24b051d55eb572b49">&#9670;&nbsp;</a></span>EFI_RESET_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceenum.html">enum</a> <a class="el" href="_uefi_spec_8h.html#aac10574bc0f1e0c24b051d55eb572b49">EFI_RESET_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of reset types. </p>
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="aac10574bc0f1e0c24b051d55eb572b49a0164249380e07fd1b999f7b611c7fc1b"></a>EfiResetCold&#160;</td><td class="fielddoc"><p>Used to induce a system-wide reset. <a class="el" href="namespace_this.html">This</a> sets all circuitry within the system to its initial state. <a class="el" href="namespace_this.html">This</a> type of reset is asynchronous to system operation and operates withgout regard to cycle boundaries. EfiColdReset is tantamount to a system power cycle. </p>
</td></tr>
<tr><td class="fieldname"><a id="aac10574bc0f1e0c24b051d55eb572b49add056ce62c5d63bd742b8ef7d4587c85"></a>EfiResetWarm&#160;</td><td class="fielddoc"><p>Used to induce a system-wide initialization. The processors are set to their initial state, and pending cycles are not corrupted. If the system does not support this reset type, then an EfiResetCold must be performed. </p>
</td></tr>
<tr><td class="fieldname"><a id="aac10574bc0f1e0c24b051d55eb572b49ad1b39698e822c87bb227272bb6f791ab"></a>EfiResetShutdown&#160;</td><td class="fielddoc"><p>Used to induce an entry into a power state equivalent to the ACPI G2/S5 or G3 state. If the system does not support this reset type, then when the system is rebooted, it should exhibit the EfiResetCold attributes. </p>
</td></tr>
</table>

</div>
</div>
<a id="a813f66495f29a8738fc7be0b60076777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813f66495f29a8738fc7be0b60076777">&#9670;&nbsp;</a></span>EFI_TIMER_DELAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceenum.html">enum</a> <a class="el" href="_uefi_spec_8h.html#a813f66495f29a8738fc7be0b60076777">EFI_TIMER_DELAY</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_timer.html">Timer</a> delay types </p>
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="a813f66495f29a8738fc7be0b60076777a2c362ea73bc229ab46d950febb9069a5"></a>TimerCancel&#160;</td><td class="fielddoc"><p>An event's timer settings is to be cancelled and not trigger time is to be set/ </p>
</td></tr>
<tr><td class="fieldname"><a id="a813f66495f29a8738fc7be0b60076777ab782ae2f652b671e2a189f237bd4311b"></a>TimerPeriodic&#160;</td><td class="fielddoc"><p>An event is to be signalled periodically at a specified interval from the current time. </p>
</td></tr>
<tr><td class="fieldname"><a id="a813f66495f29a8738fc7be0b60076777a3ee952465021f14a8514d48f8e4fcceb"></a>TimerRelative&#160;</td><td class="fielddoc"><p>An event is to be signalled once at a specified interval from the current time. </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
